Infraestructura y estructura de carpetas para "CRM para Turnos"

Resumen general
- Frontend: Next.js (SSR/SSG) + React. Despliegue recomendado en Vercel.
- Backend y persistencia: Supabase (Postgres + Auth + Storage). RLS activadas para control por roles.
- CI/CD: GitHub Actions para lint/build/test/deploy.
- Observabilidad: Sentry para errores, Google Analytics para métricas.
- Seguridad: HTTPS/HSTS, CSP, CORS limitado, secretos en GitHub/Vercel.

Estructura de carpetas (cómo quedó el proyecto)
- `/pages` - Entradas de Next.js (por ahora `/_app.tsx` y `index.tsx`).
- `/public` - Archivos públicos (favicon, imágenes estáticas).
- `/src`
  - `/components` - Componentes reutilizables (UI, vistas, panels, dialogs).
  - `/components/ui` - Componentes de diseño y primitive wrappers (botones, cards, dialogs).
  - `/components/views` - Vistas principales (HomeView, FinancesView, LoginView, etc.).
  - `/contexts` - Contextos de React (por ejemplo `AuthContext.tsx`).
  - `/hooks` - Hooks personalizados (p.ej. `useAppointments.ts`, `useClients.ts`, `useCommissions.ts`).
  - `/lib` - Librerías inicializadas (p.ej. `supabase.ts`).
  - `/assets` - Activos no públicos (referenciados por imports si es necesario).
  - `/styles` - Archivos CSS/Tailwind globales (`index.css`, `globals.css`).
- `next.config.js` - Configuración Next.js.
- `tsconfig.json` - Configuración TypeScript.
- `package.json` - Scripts y dependencias.
- `supabase_rls.sql` - SQL de ejemplo para políticas RLS por roles.
- `infrastructure.txt` - Este archivo: descripción infra, pasos y checklist.

Tablas / esquema básico en Supabase (recomendado)
- `users` (ya proveído por Supabase Auth) - almacenar role, perfil, salon_id claim si aplica.
- `appointments`:
  - id (uuid), client_name, service, date (date), time (time), status, stylist_id, salon_id, created_by
- `clients`:
  - id (uuid), name, phone, email, salon_id, notes
- `commissions`:
  - id (uuid), stylist_id, salon_id, amount, date, source_appointment_id

Políticas de acceso (RLS)
- Archivo `supabase_rls.sql` incluido con políticas genéricas:
  - `admin`: acceso completo (SELECT/INSERT/UPDATE/DELETE).
  - `owner`: acceso completo dentro de `salon_id` propio.
  - `employee`: lectura dentro del `salon_id` y permisos de actualización limitados (p.ej. solo sus propios turnos).
- Requisito: el JWT debe exponer claims `role`, `sub` (user id) y `salon_id` cuando corresponda.

Variables de entorno (debes configurarlas en Vercel / GH Secrets)
- NEXT_PUBLIC_SUPABASE_URL - URL del proyecto Supabase
- NEXT_PUBLIC_SUPABASE_ANON_KEY - Key pública de Supabase
- NEXT_PUBLIC_SENTRY_DSN - DSN de Sentry (opcional)
- NODE_ENV=production
- Otras: DATABASE_URL (si usás backend adicional), SENTRY_ENV, etc.

CI/CD (GitHub Actions) - flujo recomendado
1) On: push/PR en `main` y `develop`.
2) Jobs:
  - install: `npm install`
  - lint: `npm run lint` (eslint)
  - test: `npm run test` (vitest/jest)
  - build: `npm run build`
  - deploy: usar `vercel` action o desplegar mediante Vercel/GitHub integration

Ejemplo de pasos concretos (mini-checklist YAML)
- checkout
- setup-node
- npm ci
- npm run lint
- npm run build
- vercel/action@v20 (con token) o publicar artefacto para hosting

Despliegue en Vercel
- Conectar repo a Vercel
- Configurar Variables (NEXT_PUBLIC_SUPABASE_URL, NEXT_PUBLIC_SUPABASE_ANON_KEY, NEXT_PUBLIC_SENTRY_DSN)
- Ajustar Build Command: `npm run build` y Output Directory: (Next usa `.next` / no hace falta cambiar)
- Revisar Environment (Production/Preview)

Despliegue alternativo (S3 + CloudFront) — si no usás Next en SSR
- Generar build estático con `next export` si la app es totalmente estática
- Subir carpeta `out/` a S3 y servir con CloudFront (añadir HSTS, HTTPS)

Buenas prácticas de seguridad y operación
- Forzar HTTPS y HSTS en CDN/hosting.
- Configurar CSP en `next.config.js` o en headers del hosting.
- Limitar CORS en Supabase al dominio del frontend.
- Usar RLS en Supabase antes de abrir tablas al cliente.
- Guardar secretos en GitHub/Vercel Secrets, no en el repo.
- Revisar y rotar claves periódicamente.

Observabilidad y backups
- Integrar Sentry: capturar errores, setear `NEXT_PUBLIC_SENTRY_DSN`.
- Logs: usar Supabase logs para DB + integraciones con external logging si hace falta.
- Backups: configurar backups automáticos en Supabase / RDS.

Tests y calidad
- ESLint + Prettier
- TypeScript (estricto opcional)
- Unit tests con Vitest o Jest para hooks/logic
- E2E con Playwright / Cypress para flujos críticos (login, CRUD de turnos)

Comandos locales importantes
- `npm install` — instalar dependencias
- `npm run dev` — correr Next en dev (http://localhost:3000)
- `npm run build` — build de producción
- `npm run start` — correr Next en modo producción (después de build)
- `npm run lint` — correr ESLint
- `npm run test` — ejecutar tests

Migración de Vite → Next (qué se cambió)
- Se eliminaron `vite.config.ts`, `index.html` y `src/main.tsx`.
- Se añadió `pages/_app.tsx` y `pages/index.tsx` que montan la app cliente.
- `src/lib/supabase.ts` adaptado para SSR (inicialización tardía y stub en SSR)
- `package.json` actualizado para Next y dependencias consolidadas.

Checklist de post-migración (pendientes sugeridos)
- [ ] Revisar y actualizar `README.md` con comandos Next.
- [ ] Verificar que todas las imágenes grandes estén optimizadas (public/imagenlogin.jpg).
- [ ] Configurar Vercel con las variables env necesarias.
- [ ] Ejecutar pruebas e2e en entorno de preview.
- [ ] (Opcional) Migrar a `app/` router de Next si querés features de app dir.

Infra como código y dominio
- Si usás AWS: Terraform para S3/CloudFront, Route53 para DNS, ACM para certificados.
- Si usás Cloudflare: Pages + Workers + DNS y reglas de firewall.

Notas finales y recomendaciones rápidas
- Para un MVP interno: Next + Supabase + Vercel es rápido y seguro.
- Mantener la seguridad en la DB (RLS) y no exponer admin keys en el frontend.
- Si necesitás más ayuda: genero el workflow de GitHub Actions, un `terraform` básico para CloudFront o un script para optimizar imágenes.
