{
  "metadata": {
    "title": "‚öôÔ∏è Triggers y Automatizaci√≥n",
    "path": "docs/archive/instructivos/triggers-automacion.md",
    "category": "instructivos",
    "tags": [
      "instructivos"
    ],
    "lastUpdated": "2025-11-15",
    "fileName": "triggers-automacion"
  },
  "content": "# ‚öôÔ∏è Triggers y Automatizaci√≥n\r\n\r\nSistema completo de triggers, funciones y automatizaci√≥n en COREBOARD.\r\n\r\n## üéØ Triggers Principales\r\n\r\n### Actualizaci√≥n Autom√°tica de `updated_at`\r\n\r\n```sql\r\n-- Funci√≥n helper para timestamps\r\nCREATE OR REPLACE FUNCTION public.update_updated_at()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\n-- Aplicar a todas las tablas modificables\r\nCREATE TRIGGER update_orgs_updated_at\r\n  BEFORE UPDATE ON app.orgs\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_salons_updated_at\r\n  BEFORE UPDATE ON public.salons\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_appointments_updated_at\r\n  BEFORE UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n```\r\n\r\n**Flujo de ejecuci√≥n:**\r\n```mermaid\r\ngraph LR\r\n    A[UPDATE tabla] --> B[BEFORE UPDATE Trigger]\r\n    B --> C[update_updated_at()]\r\n    C --> D[NEW.updated_at = now()]\r\n    D --> E[Continuar UPDATE]\r\n```\r\n\r\n### C√°lculo Autom√°tico de Totales\r\n\r\n```sql\r\n-- Trigger para recalcular total de turno\r\nCREATE OR REPLACE FUNCTION public.calculate_appointment_total()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Recalcular total cuando cambian los items\r\n  UPDATE public.appointments\r\n  SET total_amount = (\r\n    SELECT COALESCE(SUM(ai.price * ai.quantity), 0)\r\n    FROM public.appointment_items ai\r\n    WHERE ai.appointment_id = NEW.appointment_id\r\n  )\r\n  WHERE id = NEW.appointment_id;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER calculate_appointment_total_trigger\r\n  AFTER INSERT OR UPDATE OR DELETE ON public.appointment_items\r\n  FOR EACH ROW EXECUTE FUNCTION public.calculate_appointment_total();\r\n```\r\n\r\n**Secuencia de c√°lculo:**\r\n```mermaid\r\nsequenceDiagram\r\n    participant U as Usuario\r\n    participant T as Trigger\r\n    participant DB as Base de Datos\r\n\r\n    U->>DB: INSERT appointment_items\r\n    DB->>T: AFTER INSERT trigger\r\n    T->>DB: UPDATE appointments SET total_amount = SUM(items)\r\n    DB->>T: Confirmaci√≥n\r\n    T->>U: Operaci√≥n completada\r\n```\r\n\r\n### Generaci√≥n Autom√°tica de Comisiones\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.generate_commission()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  emp_commission_rate numeric;\r\n  service_amount numeric;\r\n  emp_active boolean;\r\n  emp_in_salon boolean;\r\nBEGIN\r\n  -- Solo generar cuando turno se completa\r\n  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN\r\n\r\n    -- Validar que empleado existe y est√° activo\r\n    SELECT default_commission_pct, active INTO emp_commission_rate, emp_active\r\n    FROM app.employees\r\n    WHERE id = NEW.employee_id\r\n      AND user_id IS NOT NULL  -- Regla de oro\r\n      AND deleted_at IS NULL;\r\n\r\n    IF NOT FOUND OR NOT emp_active THEN\r\n      RAISE EXCEPTION 'employee_not_found_or_inactive' USING ERRCODE = 'PT400';\r\n    END IF;\r\n\r\n    -- Validar que empleado est√° asignado al sal√≥n\r\n    SELECT EXISTS (\r\n      SELECT 1 FROM public.salon_employees\r\n      WHERE salon_id = NEW.salon_id\r\n        AND employee_id = NEW.employee_id\r\n        AND active = true\r\n    ) INTO emp_in_salon;\r\n\r\n    IF NOT emp_in_salon THEN\r\n      RAISE EXCEPTION 'employee_not_in_salon' USING ERRCODE = 'PT400';\r\n    END IF;\r\n\r\n    -- Calcular monto de servicios\r\n    SELECT SUM(price * quantity) INTO service_amount\r\n    FROM public.appointment_items\r\n    WHERE appointment_id = NEW.id;\r\n\r\n    -- Crear comisi√≥n si aplica\r\n    IF emp_commission_rate > 0 AND service_amount > 0 THEN\r\n      INSERT INTO public.commissions (\r\n        org_id, employee_id, appointment_id,\r\n        amount, commission_rate, date\r\n      ) VALUES (\r\n        NEW.org_id, NEW.employee_id, NEW.id,\r\n        service_amount * (emp_commission_rate / 100.0), emp_commission_rate, NEW.date\r\n      );\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER generate_commission_trigger\r\n  AFTER UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.generate_commission();\r\n```\r\n\r\n### Validaci√≥n de Turnos (Reglas de Negocio)\r\n\r\n```sql\r\n-- Funci√≥n para validar turno antes de insertar\r\nCREATE OR REPLACE FUNCTION public.validate_appointment()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  emp_in_salon boolean;\r\n  emp_active boolean;\r\n  emp_has_user boolean;\r\nBEGIN\r\n  -- Validar que empleado existe y tiene user_id (regla de oro)\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM app.employees\r\n    WHERE id = NEW.employee_id\r\n      AND user_id IS NOT NULL\r\n      AND active = true\r\n      AND deleted_at IS NULL\r\n  ) INTO emp_has_user;\r\n\r\n  IF NOT emp_has_user THEN\r\n    RAISE EXCEPTION 'employee_missing_user_or_inactive' USING ERRCODE = 'PT400';\r\n  END IF;\r\n\r\n  -- Validar que empleado est√° asignado al sal√≥n\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.salon_employees\r\n    WHERE salon_id = NEW.salon_id\r\n      AND employee_id = NEW.employee_id\r\n      AND active = true\r\n  ) INTO emp_in_salon;\r\n\r\n  IF NOT emp_in_salon THEN\r\n    RAISE EXCEPTION 'employee_not_in_salon' USING ERRCODE = 'PT400';\r\n  END IF;\r\n\r\n  -- Validar conflictos horarios (opcional - puede ser m√°s complejo)\r\n  -- Se puede implementar aqu√≠ o en el frontend con turnosStore.checkConflicts()\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER validate_appointment_trigger\r\n  BEFORE INSERT OR UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.validate_appointment();\r\n```\r\n\r\n## üîß Funciones RPC\r\n\r\n### Claim Invitaci√≥n (Segura)\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.claim_invitation(p_token text)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public\r\nAS $$\r\nDECLARE\r\n  v_user_id uuid := auth.uid();\r\n  v_email text;\r\n  v_inv public.invitations%ROWTYPE;\r\n  v_hash bytea := digest(p_token, 'sha256');\r\nBEGIN\r\n  -- 1. Validar autenticaci√≥n\r\n  IF v_user_id IS NULL THEN\r\n    RAISE EXCEPTION 'auth_required' USING ERRCODE = 'PT401';\r\n  END IF;\r\n\r\n  -- 2. Obtener email del usuario\r\n  SELECT email INTO v_email FROM auth.users WHERE id = v_user_id;\r\n\r\n  -- 3. Buscar invitaci√≥n (FOR UPDATE = atomic)\r\n  SELECT * INTO v_inv\r\n  FROM public.invitations\r\n  WHERE token_hash = v_hash\r\n    AND used_at IS NULL\r\n    AND now() < expires_at\r\n  FOR UPDATE;\r\n\r\n  -- 4. Validaciones\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'invalid_or_expired_or_used' USING ERRCODE = 'PT403';\r\n  END IF;\r\n\r\n  IF v_inv.email IS NOT NULL AND lower(v_inv.email) <> lower(v_email) THEN\r\n    RAISE EXCEPTION 'email_mismatch' USING ERRCODE = 'PT403';\r\n  END IF;\r\n\r\n  -- 5. Crear membres√≠a (idempotent)\r\n  INSERT INTO public.memberships(org_id, user_id, role)\r\n  VALUES (v_inv.organization_id, v_user_id, v_inv.role)\r\n  ON CONFLICT (org_id, user_id) DO UPDATE SET role = EXCLUDED.role;\r\n\r\n  -- 6. Marcar como usado\r\n  UPDATE public.invitations\r\n  SET used_at = now(), used_by = v_user_id\r\n  WHERE id = v_inv.id;\r\n\r\n  -- 7. Retornar resultado\r\n  RETURN jsonb_build_object(\r\n    'organization_id', v_inv.organization_id,\r\n    'role', v_inv.role\r\n  );\r\nEND;\r\n$$;\r\n```\r\n\r\n**Diagrama de ejecuci√≥n:**\r\n```mermaid\r\nstateDiagram-v2\r\n    [*] --> ValidarAuth\r\n    ValidarAuth --> BuscarInvitacion: user_id OK\r\n    ValidarAuth --> Error401: user_id NULL\r\n\r\n    BuscarInvitacion --> ValidarToken: invitaci√≥n encontrada\r\n    BuscarInvitacion --> Error403: no encontrada\r\n\r\n    ValidarToken --> ValidarEmail: token v√°lido\r\n    ValidarToken --> Error403: token expirado/usado\r\n\r\n    ValidarEmail --> CrearMembresia: email OK\r\n    ValidarEmail --> Error403: email mismatch\r\n\r\n    CrearMembresia --> MarcarUsado\r\n    MarcarUsado --> RetornarExito\r\n    RetornarExito --> [*]\r\n\r\n    Error401 --> [*]\r\n    Error403 --> [*]\r\n```\r\n\r\n### Funciones Helper\r\n\r\n```sql\r\n-- Verificar membres√≠a en org\r\nCREATE OR REPLACE FUNCTION public.user_is_member_of(org_id uuid)\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSECURITY DEFINER\r\nAS $$\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.memberships\r\n    WHERE user_id = auth.uid() AND org_id = $1\r\n  );\r\n$$;\r\n\r\n-- Verificar rol espec√≠fico\r\nCREATE OR REPLACE FUNCTION public.user_has_role_in_org(org_id uuid, required_role text)\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSECURITY DEFINER\r\nAS $$\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.memberships\r\n    WHERE user_id = auth.uid() AND org_id = $1 AND role = $2\r\n  );\r\n$$;\r\n```\r\n\r\n## üìä Triggers de Auditor√≠a\r\n\r\n### Log de Cambios Importantes\r\n\r\n```sql\r\n-- Tabla de auditor√≠a\r\nCREATE TABLE IF NOT EXISTS public.audit_logs (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  table_name      text NOT NULL,\r\n  record_id       uuid NOT NULL,\r\n  operation       text NOT NULL CHECK (operation IN ('INSERT', 'UPDATE', 'DELETE')),\r\n  old_values      jsonb,\r\n  new_values      jsonb,\r\n  user_id         uuid REFERENCES auth.users(id),\r\n  org_id          uuid, -- Para filtrado por tenant\r\n  created_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices para performance\r\nCREATE INDEX idx_audit_logs_org ON public.audit_logs(org_id);\r\nCREATE INDEX idx_audit_logs_created ON public.audit_logs(created_at);\r\nCREATE INDEX idx_audit_logs_user ON public.audit_logs(user_id);\r\n```\r\n\r\n### Funci√≥n de Auditor√≠a Gen√©rica\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.audit_trigger_function()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nAS $$\r\nDECLARE\r\n  org_id_value uuid;\r\nBEGIN\r\n  -- Obtener org_id seg√∫n la tabla\r\n  CASE TG_TABLE_NAME\r\n    WHEN 'appointments' THEN\r\n      org_id_value := COALESCE(NEW.org_id, OLD.org_id);\r\n    WHEN 'clients' THEN\r\n      org_id_value := COALESCE(NEW.org_id, OLD.org_id);\r\n    WHEN 'payments' THEN\r\n      org_id_value := COALESCE(NEW.org_id, OLD.org_id);\r\n    ELSE\r\n      org_id_value := NULL;\r\n  END CASE;\r\n\r\n  -- Insertar en audit log\r\n  INSERT INTO public.audit_logs (\r\n    table_name, record_id, operation,\r\n    old_values, new_values, user_id, org_id\r\n  ) VALUES (\r\n    TG_TABLE_NAME,\r\n    COALESCE(NEW.id, OLD.id),\r\n    TG_OP,\r\n    CASE WHEN TG_OP != 'INSERT' THEN row_to_json(OLD) ELSE NULL END,\r\n    CASE WHEN TG_OP != 'DELETE' THEN row_to_json(NEW) ELSE NULL END,\r\n    auth.uid(),\r\n    org_id_value\r\n  );\r\n\r\n  RETURN COALESCE(NEW, OLD);\r\nEND;\r\n$$;\r\n```\r\n\r\n### Aplicar Auditor√≠a a Tablas Cr√≠ticas\r\n\r\n```sql\r\n-- Auditor√≠a en turnos\r\nCREATE TRIGGER audit_appointments_trigger\r\n  AFTER INSERT OR UPDATE OR DELETE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();\r\n\r\n-- Auditor√≠a en pagos\r\nCREATE TRIGGER audit_payments_trigger\r\n  AFTER INSERT OR UPDATE OR DELETE ON public.payments\r\n  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();\r\n\r\n-- Auditor√≠a en membres√≠as\r\nCREATE TRIGGER audit_memberships_trigger\r\n  AFTER INSERT OR UPDATE OR DELETE ON public.memberships\r\n  FOR EACH ROW EXECUTE FUNCTION public.audit_trigger_function();\r\n```\r\n\r\n## ‚è∞ Triggers de Tiempo\r\n\r\n### Recordatorios Autom√°ticos\r\n\r\n```sql\r\n-- Tabla de recordatorios programados\r\nCREATE TABLE IF NOT EXISTS public.scheduled_reminders (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  appointment_id  uuid NOT NULL REFERENCES public.appointments(id),\r\n  reminder_type   text NOT NULL CHECK (reminder_type IN ('email', 'sms', 'push')),\r\n  scheduled_for   timestamptz NOT NULL,\r\n  sent_at         timestamptz,\r\n  status          text NOT NULL DEFAULT 'pending' CHECK (status IN ('pending', 'sent', 'failed')),\r\n  created_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- Funci√≥n para crear recordatorios\r\nCREATE OR REPLACE FUNCTION public.create_appointment_reminders()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Solo para nuevos turnos confirmados\r\n  IF NEW.status = 'confirmed' AND (OLD IS NULL OR OLD.status != 'confirmed') THEN\r\n\r\n    -- Recordatorio 24h antes\r\n    INSERT INTO public.scheduled_reminders (\r\n      appointment_id, reminder_type, scheduled_for\r\n    ) VALUES (\r\n      NEW.id, 'email', NEW.date + NEW.time - interval '24 hours'\r\n    );\r\n\r\n    -- Recordatorio 1h antes\r\n    INSERT INTO public.scheduled_reminders (\r\n      appointment_id, reminder_type, scheduled_for\r\n    ) VALUES (\r\n      NEW.id, 'sms', NEW.date + NEW.time - interval '1 hour'\r\n    );\r\n\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER create_reminders_trigger\r\n  AFTER INSERT OR UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.create_appointment_reminders();\r\n```\r\n\r\n### Limpieza Autom√°tica\r\n\r\n```sql\r\n-- Funci√≥n para limpiar datos antiguos\r\nCREATE OR REPLACE FUNCTION public.cleanup_old_data()\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Eliminar logs de auditor√≠a antiguos (90 d√≠as)\r\n  DELETE FROM public.audit_logs\r\n  WHERE created_at < now() - interval '90 days';\r\n\r\n  -- Archivar turnos completados antiguos (2 a√±os)\r\n  INSERT INTO archived_appointments\r\n  SELECT * FROM public.appointments\r\n  WHERE status = 'completed'\r\n    AND date < now() - interval '2 years';\r\n\r\n  DELETE FROM public.appointments\r\n  WHERE status = 'completed'\r\n    AND date < now() - interval '2 years';\r\n\r\n  -- Limpiar invitaciones expiradas hace m√°s de 30 d√≠as\r\n  DELETE FROM public.invitations\r\n  WHERE used_at IS NULL\r\n    AND expires_at < now() - interval '30 days';\r\nEND;\r\n$$;\r\n\r\n-- Ejecutar diariamente con pg_cron o similar\r\n-- SELECT cron.schedule('cleanup-old-data', '0 2 * * *', 'SELECT public.cleanup_old_data();');\r\n```\r\n\r\n## üîÑ Workflows Autom√°ticos\r\n\r\n### Pipeline de Turno Completo\r\n\r\n```mermaid\r\ngraph TD\r\n    A[Turno Creado] --> B{¬øConfirmado?}\r\n    B -->|No| C[Esperar confirmaci√≥n]\r\n    B -->|S√≠| D[Crear recordatorios]\r\n\r\n    D --> E[24h antes: Email]\r\n    D --> F[1h antes: SMS]\r\n\r\n    E --> G[Turno ejecutado]\r\n    F --> G\r\n\r\n    G --> H{¬øCompletado?}\r\n    H -->|No| I[Esperar]\r\n    H -->|S√≠| J[Generar comisi√≥n]\r\n\r\n    J --> K[Crear pago si aplica]\r\n    K --> L[Enviar recibo]\r\n\r\n    L --> M[Actualizar estad√≠sticas]\r\n    M --> N[Fin del workflow]\r\n```\r\n\r\n### Sistema de Notificaciones\r\n\r\n```sql\r\n-- Tabla de notificaciones\r\nCREATE TABLE IF NOT EXISTS public.notifications (\r\n  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  user_id     uuid NOT NULL REFERENCES auth.users(id),\r\n  org_id      uuid NOT NULL,\r\n  type        text NOT NULL CHECK (type IN ('appointment_reminder', 'payment_received', 'commission_earned', 'system_alert')),\r\n  title       text NOT NULL,\r\n  message     text NOT NULL,\r\n  data        jsonb, -- Datos adicionales\r\n  read_at     timestamptz,\r\n  created_at  timestamptz DEFAULT now()\r\n);\r\n\r\n-- Trigger para notificaciones\r\nCREATE OR REPLACE FUNCTION public.create_notification()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Notificar al cliente cuando turno se confirma\r\n  IF NEW.status = 'confirmed' AND (OLD IS NULL OR OLD.status != 'confirmed') THEN\r\n    INSERT INTO public.notifications (\r\n      user_id, org_id, type, title, message, data\r\n    ) VALUES (\r\n      NEW.created_by, NEW.org_id, 'appointment_reminder',\r\n      'Turno confirmado',\r\n      format('Su turno para %s el %s a las %s ha sido confirmado',\r\n             NEW.client_name, NEW.date, NEW.time),\r\n      jsonb_build_object('appointment_id', NEW.id)\r\n    );\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER create_notification_trigger\r\n  AFTER UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.create_notification();\r\n```\r\n\r\n## üìà Triggers de Analytics\r\n\r\n### Estad√≠sticas Autom√°ticas\r\n\r\n```sql\r\n-- Tabla de estad√≠sticas diarias\r\nCREATE TABLE IF NOT EXISTS public.daily_stats (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL,\r\n  date            date NOT NULL,\r\n  appointments_count integer DEFAULT 0,\r\n  revenue         numeric DEFAULT 0,\r\n  clients_count   integer DEFAULT 0,\r\n  created_at      timestamptz DEFAULT now(),\r\n  UNIQUE(org_id, date)\r\n);\r\n\r\n-- Funci√≥n para actualizar estad√≠sticas\r\nCREATE OR REPLACE FUNCTION public.update_daily_stats()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Actualizar estad√≠sticas cuando turno se completa\r\n  IF NEW.status = 'completed' AND (OLD IS NULL OR OLD.status != 'completed') THEN\r\n    INSERT INTO public.daily_stats (org_id, date, appointments_count, revenue)\r\n    VALUES (NEW.org_id, NEW.date, 1, NEW.total_amount)\r\n    ON CONFLICT (org_id, date) DO UPDATE SET\r\n      appointments_count = daily_stats.appointments_count + 1,\r\n      revenue = daily_stats.revenue + NEW.total_amount;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER update_daily_stats_trigger\r\n  AFTER UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_daily_stats();\r\n```\r\n\r\n### Reportes Autom√°ticos\r\n\r\n```sql\r\n-- Funci√≥n para generar reportes semanales\r\nCREATE OR REPLACE FUNCTION public.generate_weekly_report(org_id uuid)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  result jsonb;\r\nBEGIN\r\n  SELECT jsonb_build_object(\r\n    'period', 'weekly',\r\n    'appointments', (\r\n      SELECT COUNT(*) FROM public.appointments\r\n      WHERE org_id = $1\r\n        AND date >= date_trunc('week', now())\r\n        AND date < date_trunc('week', now() + interval '1 week')\r\n    ),\r\n    'revenue', (\r\n      SELECT COALESCE(SUM(total_amount), 0) FROM public.appointments\r\n      WHERE org_id = $1\r\n        AND date >= date_trunc('week', now())\r\n        AND date < date_trunc('week', now() + interval '1 week')\r\n        AND status = 'completed'\r\n    ),\r\n    'new_clients', (\r\n      SELECT COUNT(*) FROM public.clients\r\n      WHERE org_id = $1\r\n        AND created_at >= date_trunc('week', now())\r\n    )\r\n  ) INTO result;\r\n\r\n  RETURN result;\r\nEND;\r\n$$;\r\n```\r\n\r\n## üß™ Testing de Triggers\r\n\r\n### Tests Unitarios\r\n\r\n```sql\r\n-- Test: Trigger de total autom√°tico\r\nBEGIN;\r\n  -- Crear turno\r\n  INSERT INTO public.appointments (org_id, client_name, date, time, status)\r\n  VALUES ('org-123', 'Test Client', CURRENT_DATE, '10:00', 'pending')\r\n  RETURNING id INTO appointment_id;\r\n\r\n  -- Agregar servicio\r\n  INSERT INTO public.appointment_items (appointment_id, service_id, price, quantity)\r\n  VALUES (appointment_id, 'service-123', 100, 2);\r\n\r\n  -- Verificar que total se calcul√≥\r\n  SELECT total_amount FROM public.appointments WHERE id = appointment_id;\r\n  -- Debe ser 200\r\n\r\nROLLBACK;\r\n```\r\n\r\n### Tests de Integraci√≥n\r\n\r\n```typescript\r\ndescribe('Trigger Integration Tests', () => {\r\n  test('commission generation on appointment completion', async () => {\r\n    const appointment = await createAppointment({\r\n      employeeId: 'emp-123',\r\n      services: [{ price: 100 }],\r\n      status: 'pending'\r\n    });\r\n\r\n    // Marcar como completado\r\n    await updateAppointment(appointment.id, { status: 'completed' });\r\n\r\n    // Verificar comisi√≥n creada\r\n    const commissions = await getCommissions(appointment.id);\r\n    expect(commissions.length).toBe(1);\r\n    expect(commissions[0].amount).toBe(100 * 0.5); // 50% commission\r\n  });\r\n});\r\n```\r\n\r\n## üìä Monitoreo de Triggers\r\n\r\n### Performance de Triggers\r\n\r\n```sql\r\n-- Ver tiempo de ejecuci√≥n de triggers\r\nSELECT\r\n  event_object_table as table_name,\r\n  trigger_name,\r\n  action_timing,\r\n  action_orientation,\r\n  action_statement\r\nFROM information_schema.triggers\r\nWHERE trigger_schema = 'public'\r\nORDER BY event_object_table;\r\n\r\n-- Ver si triggers est√°n habilitados\r\nSELECT\r\n  tgname as trigger_name,\r\n  tgenabled as enabled,\r\n  tgrelid::regclass as table_name\r\nFROM pg_trigger\r\nWHERE tgname LIKE '%trigger%'\r\nORDER BY tgname;\r\n```\r\n\r\n### Logs de Errores\r\n\r\n```sql\r\n-- Tabla para errores de triggers\r\nCREATE TABLE IF NOT EXISTS public.trigger_errors (\r\n  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  trigger_name text NOT NULL,\r\n  table_name  text NOT NULL,\r\n  error_message text NOT NULL,\r\n  record_data jsonb,\r\n  occurred_at timestamptz DEFAULT now()\r\n);\r\n\r\n-- Funci√≥n para logging de errores\r\nCREATE OR REPLACE FUNCTION public.log_trigger_error(\r\n  p_trigger_name text,\r\n  p_table_name text,\r\n  p_error text,\r\n  p_record jsonb DEFAULT NULL\r\n)\r\nRETURNS void\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  INSERT INTO public.trigger_errors (\r\n    trigger_name, table_name, error_message, record_data\r\n  ) VALUES (\r\n    p_trigger_name, p_table_name, p_error, p_record\r\n  );\r\nEND;\r\n$$;\r\n```\r\n\r\n---\r\n\r\n**Triggers implementados:** ‚úÖ Actualizaci√≥n autom√°tica, ‚úÖ C√°lculo de totales, ‚úÖ Generaci√≥n de comisiones, ‚úÖ Validaci√≥n de turnos (regla de oro), ‚úÖ Auditor√≠a completa, ‚úÖ Notificaciones autom√°ticas\r\n**√öltima actualizaci√≥n:** Noviembre 2025\r\n\r\n## üìã Cambios Recientes (v2.0.0)\r\n\r\n### Validaciones en Triggers\r\n- ‚úÖ **`validate_appointment()`**: Valida empleado asignado al sal√≥n antes de insertar/actualizar turno\r\n- ‚úÖ **`generate_commission()`**: Valida regla de oro (user_id) y asignaci√≥n activa antes de generar comisi√≥n\r\n- ‚úÖ **Validaci√≥n de conflictos**: Se hace en frontend con `turnosStore.checkConflicts()` (m√°s flexible)\r\n",
  "sections": []
}