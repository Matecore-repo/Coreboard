{
  "metadata": {
    "title": "üóÑÔ∏è Base de Datos - Arquitectura Multi-Tenant",
    "path": "docs/archive/instructivos/base-datos.md",
    "category": "instructivos",
    "tags": [
      "instructivos"
    ],
    "lastUpdated": "2025-11-15",
    "fileName": "base-datos"
  },
  "content": "# üóÑÔ∏è Base de Datos - Arquitectura Multi-Tenant\r\n\r\nCOREBOARD utiliza PostgreSQL con Supabase para una arquitectura multi-tenant robusta con triggers autom√°ticos.\r\n\r\n## üèóÔ∏è Arquitectura General\r\n\r\n```\r\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\r\n‚îÇ                    SUPABASE (PostgreSQL)                    ‚îÇ\r\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r\n‚îÇ  auth.*          ‚îÇ  app.*           ‚îÇ  public.*            ‚îÇ\r\n‚îÇ  (Autenticaci√≥n) ‚îÇ  (Core multi-    ‚îÇ  (Tenant data)       ‚îÇ\r\n‚îÇ  - users         ‚îÇ   tenant)        ‚îÇ  - memberships       ‚îÇ\r\n‚îÇ  - sessions      ‚îÇ  - orgs          ‚îÇ  - salons            ‚îÇ\r\n‚îÇ  - tokens        ‚îÇ                  ‚îÇ  - services          ‚îÇ\r\n‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\r\n‚îÇ  RLS Policies    ‚îÇ  Triggers        ‚îÇ  Functions RPC       ‚îÇ\r\n‚îÇ  (Security)      ‚îÇ  (Automation)    ‚îÇ  (API)               ‚îÇ\r\n‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\r\n```\r\n\r\n## üìä Esquema Completo\r\n\r\n### üè¢ Core Multi-Tenant (`app.*`)\r\n\r\n#### Organizaciones (`app.organizations` o `app.orgs`)\r\n```sql\r\nCREATE TABLE app.organizations (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  name            text NOT NULL,\r\n  tax_id          text,                    -- CUIT/CUIL\r\n  settings        jsonb DEFAULT '{}',      -- Config org\r\n  created_at      timestamptz DEFAULT now(),\r\n  updated_at      timestamptz DEFAULT now(),\r\n  deleted_at      timestamptz              -- Soft delete\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_orgs_name ON app.organizations(name);\r\nCREATE INDEX idx_orgs_deleted ON app.organizations(deleted_at) WHERE deleted_at IS NULL;\r\n```\r\n\r\n**Nota**: Para compatibilidad, puede existir `app.orgs` como alias. En sistemas nuevos, usar `app.organizations`.\r\n\r\n#### Membres√≠as (`app.memberships`)\r\n```sql\r\nCREATE TABLE app.memberships (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL REFERENCES app.organizations(id) ON DELETE CASCADE,\r\n  user_id         uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  role            text NOT NULL CHECK (role IN ('owner','admin','employee','viewer')),\r\n  is_primary      boolean DEFAULT false,   -- Org principal del usuario\r\n  created_at      timestamptz DEFAULT now(),\r\n  UNIQUE(org_id, user_id)                  -- Un usuario por org\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_memberships_user ON app.memberships(user_id);\r\nCREATE INDEX idx_memberships_org ON app.memberships(org_id);\r\nCREATE INDEX idx_memberships_role ON app.memberships(role);\r\n```\r\n\r\n### üè™ Datos de Negocio (`public.*`)\r\n\r\n#### Salones (`app.salons`)\r\n```sql\r\nCREATE TABLE app.salons (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL REFERENCES app.organizations(id) ON DELETE CASCADE,\r\n  name            text NOT NULL,\r\n  address         text,\r\n  phone           text,\r\n  timezone        text DEFAULT 'America/Argentina/Buenos_Aires',\r\n  active          boolean DEFAULT true,\r\n  created_at      timestamptz DEFAULT now(),\r\n  updated_at      timestamptz DEFAULT now(),\r\n  deleted_at      timestamptz                    -- Soft delete\r\n  -- staff: string[] ELIMINADO - ahora usa salon_employees\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_salons_org ON app.salons(org_id);\r\nCREATE INDEX idx_salons_active ON app.salons(active) WHERE active = true;\r\n```\r\n\r\n**Nota**: El campo `staff` (array de strings) fue eliminado. Las asignaciones de empleados ahora se gestionan mediante la tabla `salon_employees` (many-to-many).\r\n\r\n#### Servicios (`app.services`)\r\n```sql\r\nCREATE TABLE app.services (\r\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id           uuid NOT NULL REFERENCES app.organizations(id) ON DELETE CASCADE,\r\n  name             text NOT NULL,\r\n  description      text,\r\n  base_price       numeric NOT NULL DEFAULT 0,\r\n  duration_minutes integer DEFAULT 60,\r\n  active           boolean DEFAULT true,\r\n  created_at       timestamptz DEFAULT now(),\r\n  updated_at       timestamptz DEFAULT now(),\r\n  deleted_at       timestamptz                    -- Soft delete\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_services_org ON app.services(org_id);\r\nCREATE INDEX idx_services_active ON app.services(active) WHERE active = true;\r\n```\r\n\r\n#### Precios por Sal√≥n (`public.salon_service_prices`)\r\n```sql\r\nCREATE TABLE public.salon_service_prices (\r\n  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  salon_id    uuid NOT NULL REFERENCES public.salons(id) ON DELETE CASCADE,\r\n  service_id  uuid NOT NULL REFERENCES public.services(id) ON DELETE CASCADE,\r\n  price       numeric NOT NULL,                    -- Precio override\r\n  created_at  timestamptz DEFAULT now(),\r\n  UNIQUE(salon_id, service_id)                     -- Un precio por servicio/sal√≥n\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_salon_prices_salon ON public.salon_service_prices(salon_id);\r\nCREATE INDEX idx_salon_prices_service ON public.salon_service_prices(service_id);\r\n```\r\n\r\n#### Empleados (`app.employees`)\r\n```sql\r\nCREATE TABLE app.employees (\r\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id           uuid NOT NULL REFERENCES app.organizations(id) ON DELETE CASCADE,\r\n  user_id          uuid NOT NULL REFERENCES auth.users(id) ON DELETE CASCADE,\r\n  full_name        text NOT NULL,\r\n  email            text,\r\n  phone            text,\r\n  default_commission_pct numeric DEFAULT 50.0,    -- 50% default\r\n  active           boolean DEFAULT true,\r\n  created_at       timestamptz DEFAULT now(),\r\n  updated_at       timestamptz DEFAULT now(),\r\n  deleted_at       timestamptz                    -- Soft delete\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_employees_org ON app.employees(org_id);\r\nCREATE INDEX idx_employees_user ON app.employees(user_id);\r\nCREATE INDEX idx_employees_active ON app.employees(active) WHERE active = true;\r\nCREATE UNIQUE INDEX idx_employees_org_user ON app.employees(org_id, user_id) WHERE deleted_at IS NULL;\r\n\r\n-- Constraint: user_id obligatorio (regla de oro)\r\nALTER TABLE app.employees ADD CONSTRAINT employees_user_id_required CHECK (user_id IS NOT NULL);\r\n```\r\n\r\n**Regla de Oro**: Empleado = Usuario autenticado. No existe empleado sin `user_id`. Esta regla se valida en:\r\n- Base de datos: constraint `employees_user_id_required`\r\n- Frontend: `employeeValidator.ts` filtra empleados sin `user_id`\r\n- Hooks: `useEmployees` aplica `filterValidEmployees` autom√°ticamente\r\n\r\n#### Asignaciones Sal√≥n-Empleado (`public.salon_employees`)\r\n```sql\r\nCREATE TABLE public.salon_employees (\r\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  salon_id         uuid NOT NULL REFERENCES app.salons(id) ON DELETE CASCADE,\r\n  employee_id      uuid NOT NULL REFERENCES app.employees(id) ON DELETE CASCADE,\r\n  active           boolean DEFAULT true,\r\n  assigned_at      timestamptz DEFAULT now(),\r\n  assigned_by      uuid REFERENCES auth.users(id),\r\n  UNIQUE(salon_id, employee_id)                    -- Un empleado solo una vez por sal√≥n\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_salon_employees_salon ON public.salon_employees(salon_id);\r\nCREATE INDEX idx_salon_employees_employee ON public.salon_employees(employee_id);\r\nCREATE INDEX idx_salon_employees_active ON public.salon_employees(active) WHERE active = true;\r\n```\r\n\r\n**Nota**: Reemplaza el array de strings `staff` en salones. Asignaciones many-to-many con validaci√≥n de empleado activo.\r\n\r\n#### Clientes (`public.clients`)\r\n```sql\r\nCREATE TABLE public.clients (\r\n  id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id      uuid NOT NULL REFERENCES app.orgs(id) ON DELETE CASCADE,\r\n  name        text NOT NULL,\r\n  phone       text,\r\n  email       text,\r\n  notes       text,\r\n  created_at  timestamptz DEFAULT now(),\r\n  updated_at  timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_clients_org ON public.clients(org_id);\r\nCREATE INDEX idx_clients_name ON public.clients(name);\r\nCREATE INDEX idx_clients_phone ON public.clients(phone);\r\n```\r\n\r\n#### Turnos (`public.appointments`)\r\n```sql\r\nCREATE TABLE public.appointments (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL REFERENCES app.organizations(id) ON DELETE CASCADE,\r\n  salon_id        uuid NOT NULL REFERENCES app.salons(id) ON DELETE CASCADE,\r\n  client_id       uuid REFERENCES public.clients(id) ON DELETE SET NULL,\r\n  client_name     text NOT NULL,                    -- Denormalized\r\n  employee_id     uuid NOT NULL REFERENCES app.employees(id) ON DELETE SET NULL,\r\n  date            date NOT NULL,\r\n  time            time NOT NULL,\r\n  status          text NOT NULL CHECK (status IN ('pending','confirmed','completed','cancelled')),\r\n  total_amount    numeric NOT NULL DEFAULT 0,\r\n  notes           text,\r\n  created_by      uuid NOT NULL REFERENCES auth.users(id),\r\n  created_at      timestamptz DEFAULT now(),\r\n  updated_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- Validaci√≥n: employee_id debe estar asignado al sal√≥n\r\n-- Se valida con trigger validate_appointment() o en frontend con turnosStore\r\n\r\n-- √çndices\r\nCREATE INDEX idx_appointments_org ON public.appointments(org_id);\r\nCREATE INDEX idx_appointments_salon ON public.appointments(salon_id);\r\nCREATE INDEX idx_appointments_date ON public.appointments(date);\r\nCREATE INDEX idx_appointments_status ON public.appointments(status);\r\nCREATE INDEX idx_appointments_employee ON public.appointments(employee_id);\r\nCREATE INDEX idx_appointments_created_by ON public.appointments(created_by);\r\nCREATE INDEX idx_appointments_salon_date ON public.appointments(salon_id, date);\r\n```\r\n\r\n#### √çtems de Turno (`public.appointment_items`)\r\n```sql\r\nCREATE TABLE public.appointment_items (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  appointment_id  uuid NOT NULL REFERENCES public.appointments(id) ON DELETE CASCADE,\r\n  service_id      uuid NOT NULL REFERENCES public.services(id) ON DELETE CASCADE,\r\n  price           numeric NOT NULL,                    -- Precio al momento\r\n  quantity        integer DEFAULT 1,\r\n  created_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_appointment_items_appointment ON public.appointment_items(appointment_id);\r\nCREATE INDEX idx_appointment_items_service ON public.appointment_items(service_id);\r\n```\r\n\r\n#### Pagos (`public.payments`)\r\n```sql\r\nCREATE TABLE public.payments (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL REFERENCES app.orgs(id) ON DELETE CASCADE,\r\n  appointment_id  uuid REFERENCES public.appointments(id) ON DELETE SET NULL,\r\n  amount          numeric NOT NULL,\r\n  payment_method  text NOT NULL CHECK (payment_method IN ('cash','card','transfer','other')),\r\n  date            date NOT NULL,\r\n  notes           text,\r\n  created_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_payments_org ON public.payments(org_id);\r\nCREATE INDEX idx_payments_appointment ON public.payments(appointment_id);\r\nCREATE INDEX idx_payments_date ON public.payments(date);\r\n```\r\n\r\n#### Gastos (`public.expenses`)\r\n```sql\r\nCREATE TABLE public.expenses (\r\n  id              uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id          uuid NOT NULL REFERENCES app.orgs(id) ON DELETE CASCADE,\r\n  salon_id        uuid REFERENCES public.salons(id) ON DELETE SET NULL,\r\n  amount          numeric NOT NULL,\r\n  description     text NOT NULL,\r\n  category        text,\r\n  date            date NOT NULL,\r\n  created_by      uuid NOT NULL REFERENCES auth.users(id),\r\n  created_at      timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_expenses_org ON public.expenses(org_id);\r\nCREATE INDEX idx_expenses_salon ON public.expenses(salon_id);\r\nCREATE INDEX idx_expenses_date ON public.expenses(date);\r\nCREATE INDEX idx_expenses_created_by ON public.expenses(created_by);\r\n```\r\n\r\n#### Comisiones (`public.commissions`)\r\n```sql\r\nCREATE TABLE public.commissions (\r\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  org_id           uuid NOT NULL REFERENCES app.orgs(id) ON DELETE CASCADE,\r\n  employee_id      uuid NOT NULL REFERENCES public.employees(id) ON DELETE CASCADE,\r\n  appointment_id   uuid REFERENCES public.appointments(id) ON DELETE SET NULL,\r\n  amount           numeric NOT NULL,\r\n  commission_rate  numeric NOT NULL,\r\n  date             date NOT NULL,\r\n  created_at       timestamptz DEFAULT now()\r\n);\r\n\r\n-- √çndices\r\nCREATE INDEX idx_commissions_org ON public.commissions(org_id);\r\nCREATE INDEX idx_commissions_employee ON public.commissions(employee_id);\r\nCREATE INDEX idx_commissions_appointment ON public.commissions(appointment_id);\r\nCREATE INDEX idx_commissions_date ON public.commissions(date);\r\n```\r\n\r\n### üé´ Sistema de Invitaciones (`public.invitations`)\r\n\r\n```sql\r\nCREATE TABLE public.invitations (\r\n  id               uuid PRIMARY KEY DEFAULT gen_random_uuid(),\r\n  organization_id  uuid NOT NULL REFERENCES app.orgs(id) ON DELETE CASCADE,\r\n  email            text,                          -- Opcional\r\n  role             text NOT NULL CHECK (role IN ('owner','admin','employee','viewer')),\r\n  token_hash       bytea NOT NULL,                -- SHA-256\r\n  expires_at       timestamptz NOT NULL DEFAULT (now() + interval '7 days'),\r\n  used_at          timestamptz,\r\n  used_by          uuid REFERENCES auth.users(id),\r\n  created_by       uuid REFERENCES auth.users(id),\r\n  created_at       timestamptz NOT NULL DEFAULT now()\r\n);\r\n\r\n-- √çndices cr√≠ticos de seguridad\r\nCREATE INDEX idx_invitations_org ON public.invitations(organization_id);\r\nCREATE UNIQUE INDEX invitations_token_unique_open\r\n  ON public.invitations(token_hash) WHERE used_at IS NULL;\r\nCREATE UNIQUE INDEX invitations_unique_pending_email\r\n  ON public.invitations(organization_id, email) WHERE used_at IS NULL AND email IS NOT NULL;\r\n```\r\n\r\n## ‚öôÔ∏è Triggers y Automatizaci√≥n\r\n\r\n### Trigger: Actualizar `updated_at`\r\n\r\n```sql\r\n-- Funci√≥n helper\r\nCREATE OR REPLACE FUNCTION public.update_updated_at()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  NEW.updated_at = now();\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\n-- Aplicar a tablas que lo necesitan\r\nCREATE TRIGGER update_organizations_updated_at\r\n  BEFORE UPDATE ON app.organizations\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_salons_updated_at\r\n  BEFORE UPDATE ON app.salons\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_services_updated_at\r\n  BEFORE UPDATE ON app.services\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_employees_updated_at\r\n  BEFORE UPDATE ON app.employees\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n\r\nCREATE TRIGGER update_appointments_updated_at\r\n  BEFORE UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at();\r\n```\r\n\r\n### Trigger: Calcular Total de Turno\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.calculate_appointment_total()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nBEGIN\r\n  -- Recalcular total cuando cambian los items\r\n  UPDATE public.appointments\r\n  SET total_amount = (\r\n    SELECT COALESCE(SUM(ai.price * ai.quantity), 0)\r\n    FROM public.appointment_items ai\r\n    WHERE ai.appointment_id = NEW.appointment_id\r\n  )\r\n  WHERE id = NEW.appointment_id;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER calculate_appointment_total_trigger\r\n  AFTER INSERT OR UPDATE OR DELETE ON public.appointment_items\r\n  FOR EACH ROW EXECUTE FUNCTION public.calculate_appointment_total();\r\n```\r\n\r\n### Trigger: Generar Comisiones\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.generate_commission()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  emp_commission_rate numeric;\r\n  service_amount numeric;\r\n  emp_active boolean;\r\n  emp_in_salon boolean;\r\nBEGIN\r\n  -- Solo generar comisi√≥n cuando turno se completa\r\n  IF NEW.status = 'completed' AND (OLD.status IS NULL OR OLD.status != 'completed') THEN\r\n\r\n    -- Validar que empleado existe y est√° activo (regla de oro)\r\n    SELECT default_commission_pct, active INTO emp_commission_rate, emp_active\r\n    FROM app.employees\r\n    WHERE id = NEW.employee_id\r\n      AND user_id IS NOT NULL  -- Regla de oro\r\n      AND deleted_at IS NULL;\r\n\r\n    IF NOT FOUND OR NOT emp_active THEN\r\n      RAISE EXCEPTION 'employee_not_found_or_inactive' USING ERRCODE = 'PT400';\r\n    END IF;\r\n\r\n    -- Validar que empleado est√° asignado al sal√≥n\r\n    SELECT EXISTS (\r\n      SELECT 1 FROM public.salon_employees\r\n      WHERE salon_id = NEW.salon_id\r\n        AND employee_id = NEW.employee_id\r\n        AND active = true\r\n    ) INTO emp_in_salon;\r\n\r\n    IF NOT emp_in_salon THEN\r\n      RAISE EXCEPTION 'employee_not_in_salon' USING ERRCODE = 'PT400';\r\n    END IF;\r\n\r\n    -- Calcular monto de servicios\r\n    SELECT SUM(price * quantity) INTO service_amount\r\n    FROM public.appointment_items\r\n    WHERE appointment_id = NEW.id;\r\n\r\n    -- Insertar comisi√≥n si hay empleado y monto\r\n    IF emp_commission_rate > 0 AND service_amount > 0 THEN\r\n      INSERT INTO public.commissions (\r\n        org_id, employee_id, appointment_id,\r\n        amount, commission_rate, date\r\n      ) VALUES (\r\n        NEW.org_id, NEW.employee_id, NEW.id,\r\n        service_amount * (emp_commission_rate / 100.0), emp_commission_rate, NEW.date\r\n      );\r\n    END IF;\r\n  END IF;\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER generate_commission_trigger\r\n  AFTER UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.generate_commission();\r\n```\r\n\r\n### Trigger: Validar Turnos (Reglas de Negocio)\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.validate_appointment()\r\nRETURNS trigger\r\nLANGUAGE plpgsql\r\nAS $$\r\nDECLARE\r\n  emp_in_salon boolean;\r\n  emp_active boolean;\r\n  emp_has_user boolean;\r\nBEGIN\r\n  -- Validar que empleado existe y tiene user_id (regla de oro)\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM app.employees\r\n    WHERE id = NEW.employee_id\r\n      AND user_id IS NOT NULL\r\n      AND active = true\r\n      AND deleted_at IS NULL\r\n  ) INTO emp_has_user;\r\n\r\n  IF NOT emp_has_user THEN\r\n    RAISE EXCEPTION 'employee_missing_user_or_inactive' USING ERRCODE = 'PT400';\r\n  END IF;\r\n\r\n  -- Validar que empleado est√° asignado al sal√≥n\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM public.salon_employees\r\n    WHERE salon_id = NEW.salon_id\r\n      AND employee_id = NEW.employee_id\r\n      AND active = true\r\n  ) INTO emp_in_salon;\r\n\r\n  IF NOT emp_in_salon THEN\r\n    RAISE EXCEPTION 'employee_not_in_salon' USING ERRCODE = 'PT400';\r\n  END IF;\r\n\r\n  -- Validaci√≥n de conflictos horarios se hace en frontend con turnosStore.checkConflicts()\r\n\r\n  RETURN NEW;\r\nEND;\r\n$$;\r\n\r\nCREATE TRIGGER validate_appointment_trigger\r\n  BEFORE INSERT OR UPDATE ON public.appointments\r\n  FOR EACH ROW EXECUTE FUNCTION public.validate_appointment();\r\n```\r\n\r\n## üîß Funciones RPC\r\n\r\n### Claim Invitaci√≥n (Seguro)\r\n\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.claim_invitation(p_token text)\r\nRETURNS jsonb\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, app\r\nAS $$\r\nDECLARE\r\n  v_user_id uuid := auth.uid();\r\n  v_email text;\r\n  v_inv public.invitations%ROWTYPE;\r\n  v_hash bytea := digest(p_token, 'sha256');\r\nBEGIN\r\n  -- Validar autenticaci√≥n\r\n  IF v_user_id IS NULL THEN\r\n    RAISE EXCEPTION 'auth_required' USING ERRCODE = 'PT401';\r\n  END IF;\r\n\r\n  -- Obtener email del usuario\r\n  SELECT email INTO v_email FROM auth.users WHERE id = v_user_id;\r\n\r\n  -- Buscar invitaci√≥n (FOR UPDATE previene race conditions)\r\n  SELECT * INTO v_inv\r\n  FROM public.invitations\r\n  WHERE token_hash = v_hash\r\n    AND used_at IS NULL\r\n    AND now() < expires_at\r\n  FOR UPDATE;\r\n\r\n  -- Validar invitaci√≥n\r\n  IF NOT FOUND THEN\r\n    RAISE EXCEPTION 'invalid_or_expired_or_used' USING ERRCODE = 'PT403';\r\n  END IF;\r\n\r\n  -- Validar email si est√° restringido\r\n  IF v_inv.email IS NOT NULL AND lower(v_inv.email) <> lower(v_email) THEN\r\n    RAISE EXCEPTION 'email_mismatch' USING ERRCODE = 'PT403';\r\n  END IF;\r\n\r\n  -- Crear membres√≠a (idempotente)\r\n  INSERT INTO app.memberships(org_id, user_id, role)\r\n  VALUES (v_inv.organization_id, v_user_id, v_inv.role)\r\n  ON CONFLICT (org_id, user_id) DO UPDATE SET role = EXCLUDED.role;\r\n\r\n  -- Marcar como usada\r\n  UPDATE public.invitations\r\n  SET used_at = now(), used_by = v_user_id\r\n  WHERE id = v_inv.id;\r\n\r\n  -- Retornar info\r\n  RETURN jsonb_build_object(\r\n    'organization_id', v_inv.organization_id,\r\n    'role', v_inv.role\r\n  );\r\nEND;\r\n$$;\r\n```\r\n\r\n### Funciones Helper\r\n\r\n```sql\r\n-- Verificar membres√≠a\r\nCREATE OR REPLACE FUNCTION public.user_is_member_of(org_id uuid)\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSECURITY DEFINER\r\nSET search_path = public, app\r\nAS $$\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM app.memberships\r\n    WHERE user_id = auth.uid() AND org_id = $1\r\n  );\r\n$$;\r\n\r\n-- Verificar rol\r\nCREATE OR REPLACE FUNCTION public.user_has_role_in_org(org_id uuid, required_role text)\r\nRETURNS boolean\r\nLANGUAGE sql\r\nSECURITY DEFINER\r\nSET search_path = public, app\r\nAS $$\r\n  SELECT EXISTS (\r\n    SELECT 1 FROM app.memberships\r\n    WHERE user_id = auth.uid() AND org_id = $1 AND role = $2\r\n  );\r\n$$;\r\n```\r\n\r\n## üìä Consultas de Monitoreo\r\n\r\n### Estad√≠sticas por Organizaci√≥n\r\n```sql\r\nSELECT\r\n  o.name as org_name,\r\n  COUNT(DISTINCT m.user_id) as total_users,\r\n  COUNT(DISTINCT s.id) as total_salons,\r\n  COUNT(DISTINCT e.id) as total_employees,\r\n  COUNT(DISTINCT se.id) as total_salon_assignments,\r\n  COUNT(DISTINCT srv.id) as total_services,\r\n  COUNT(DISTINCT a.id) as total_appointments,\r\n  COUNT(DISTINCT c.id) as total_clients\r\nFROM app.organizations o\r\nLEFT JOIN app.memberships m ON o.id = m.org_id\r\nLEFT JOIN app.salons s ON o.id = s.org_id\r\nLEFT JOIN app.employees e ON o.id = e.org_id AND e.user_id IS NOT NULL AND e.deleted_at IS NULL\r\nLEFT JOIN public.salon_employees se ON e.id = se.employee_id AND se.active = true\r\nLEFT JOIN app.services srv ON o.id = srv.org_id\r\nLEFT JOIN public.appointments a ON o.id = a.org_id\r\nLEFT JOIN public.clients c ON o.id = c.org_id\r\nWHERE o.deleted_at IS NULL\r\nGROUP BY o.id, o.name\r\nORDER BY total_users DESC;\r\n```\r\n\r\n### Rendimiento por Mes\r\n```sql\r\nSELECT\r\n  DATE_TRUNC('month', a.date) as month,\r\n  COUNT(*) as appointments,\r\n  SUM(a.total_amount) as revenue,\r\n  AVG(a.total_amount) as avg_appointment_value\r\nFROM public.appointments a\r\nWHERE a.status = 'completed'\r\n  AND a.date >= DATE_TRUNC('month', CURRENT_DATE - INTERVAL '12 months')\r\nGROUP BY DATE_TRUNC('month', a.date)\r\nORDER BY month DESC;\r\n```\r\n\r\n### Usuarios Sin Actividad\r\n```sql\r\nSELECT\r\n  u.email,\r\n  m.role,\r\n  o.name as org_name,\r\n  MAX(a.date) as last_appointment,\r\n  EXTRACT(DAY FROM now() - MAX(a.date)) as days_inactive\r\nFROM auth.users u\r\nJOIN app.memberships m ON u.id = m.user_id\r\nJOIN app.organizations o ON m.org_id = o.id\r\nLEFT JOIN public.appointments a ON u.id = a.created_by\r\nWHERE o.deleted_at IS NULL\r\nGROUP BY u.id, u.email, m.role, o.name\r\nHAVING MAX(a.date) < CURRENT_DATE - INTERVAL '30 days'\r\n   OR MAX(a.date) IS NULL\r\nORDER BY days_inactive DESC NULLS FIRST;\r\n```\r\n\r\n### Empleados sin Asignaci√≥n a Sal√≥n\r\n```sql\r\n-- Empleados activos que no est√°n asignados a ning√∫n sal√≥n\r\nSELECT\r\n  e.id,\r\n  e.full_name,\r\n  e.email,\r\n  o.name as org_name,\r\n  COUNT(se.id) as salon_assignments\r\nFROM app.employees e\r\nJOIN app.organizations o ON e.org_id = o.id\r\nLEFT JOIN public.salon_employees se ON e.id = se.employee_id AND se.active = true\r\nWHERE e.user_id IS NOT NULL  -- Regla de oro\r\n  AND e.active = true\r\n  AND e.deleted_at IS NULL\r\n  AND o.deleted_at IS NULL\r\nGROUP BY e.id, e.full_name, e.email, o.name\r\nHAVING COUNT(se.id) = 0\r\nORDER BY o.name, e.full_name;\r\n```\r\n\r\n## üîÑ Migraciones\r\n\r\n### Versionado de Schema\r\n```sql\r\n-- Tabla de control de migraciones\r\nCREATE TABLE IF NOT EXISTS public.schema_migrations (\r\n  version     text PRIMARY KEY,\r\n  description text NOT NULL,\r\n  applied_at  timestamptz DEFAULT now()\r\n);\r\n\r\n-- Insertar versi√≥n actual\r\nINSERT INTO public.schema_migrations (version, description)\r\nVALUES ('2.0.0', 'Schema actualizado: salon_employees, regla de oro empleados, turnosStore')\r\nON CONFLICT (version) DO NOTHING;\r\n```\r\n\r\n### Estrategia de Migraciones\r\n1. **DDL Changes**: Crear nuevas tablas/columnas primero\r\n2. **Data Migration**: Migrar datos existentes\r\n3. **RLS Updates**: Actualizar pol√≠ticas de seguridad\r\n4. **Cleanup**: Remover c√≥digo legacy\r\n5. **Testing**: Validar integridad post-migraci√≥n\r\n\r\n## üö® Backup y Recovery\r\n\r\n### Backup Estrat√©gico\r\n```bash\r\n# Backup completo (ejecutar con service key)\r\npg_dump \"postgresql://postgres:[PASSWORD]@db.[PROJECT].supabase.co:5432/postgres\" \\\r\n  --schema=app --schema=public --schema=auth \\\r\n  --no-owner --no-privileges --clean \\\r\n  > coreboard_backup_$(date +%Y%m%d).sql\r\n```\r\n\r\n### Restore Procedure\r\n```sql\r\n-- 1. Crear nueva base si es necesario\r\n-- 2. Restaurar schema\r\npsql [CONNECTION_STRING] < coreboard_backup.sql\r\n\r\n-- 3. Verificar integridad\r\nSELECT COUNT(*) FROM app.orgs;\r\nSELECT COUNT(*) FROM public.memberships;\r\n-- etc...\r\n\r\n-- 4. Recrear RLS policies si se perdieron\r\n-- (Las policies se incluyen en el dump)\r\n```\r\n\r\n## üìà Optimizaciones\r\n\r\n### √çndices Estrat√©gicos\r\n```sql\r\n-- √çndices para queries comunes\r\nCREATE INDEX CONCURRENTLY idx_appointments_org_date\r\n  ON public.appointments(org_id, date);\r\n\r\nCREATE INDEX CONCURRENTLY idx_clients_org_name\r\n  ON public.clients(org_id, name);\r\n\r\n-- √çndices parciales para estados activos\r\nCREATE INDEX CONCURRENTLY idx_services_org_active\r\n  ON public.services(org_id, name) WHERE is_active = true;\r\n```\r\n\r\n### Partitioning (Futuro)\r\n```sql\r\n-- Para tablas grandes como appointments\r\nCREATE TABLE public.appointments_y2025 PARTITION OF public.appointments\r\n  FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');\r\n\r\n-- √çndices por partici√≥n\r\nCREATE INDEX idx_appointments_y2025_date\r\n  ON public.appointments_y2025(date);\r\n```\r\n\r\n**Versi√≥n:** 2.0.0\r\n**√öltima actualizaci√≥n:** Noviembre 2025\r\n",
  "sections": []
}