{
  "metadata": {
    "title": "ARCHITECTURE.md - An√°lisis Completo de Coreboard",
    "path": "docs/ARCHITECTURE.md",
    "category": "architecture",
    "tags": [
      "architecture",
      "#2",
      "#3",
      "#4",
      "#5",
      "#6",
      "#7",
      "#8"
    ],
    "lastUpdated": "2025-11-15",
    "fileName": "ARCHITECTURE"
  },
  "content": "# ARCHITECTURE.md - An√°lisis Completo de Coreboard\r\n\r\n## üéØ Resumen Ejecutivo\r\n\r\nCoreboard es un CRM de turnos para salones/peluquer√≠as construido con Next.js + Supabase + React. Soporta:\r\n- Multi-organizaci√≥n con RLS (Row Level Security)\r\n- Autenticaci√≥n con Supabase Auth\r\n- Modo demo sin backend para pruebas\r\n- Interfaz moderna con componentes reutilizables\r\n- Gesti√≥n completa de turnos, clientes, empleados, servicios\r\n\r\n---\r\n\r\n## üìÅ Estructura General de `src/`\r\n\r\n```\r\nsrc/\r\n‚îú‚îÄ‚îÄ App.tsx                 # Shell principal - routing y estado global\r\n‚îú‚îÄ‚îÄ contexts/\r\n‚îÇ   ‚îî‚îÄ‚îÄ AuthContext.tsx     # Gesti√≥n de sesi√≥n, usuario, organizaci√≥n\r\n‚îú‚îÄ‚îÄ stores/\r\n‚îÇ   ‚îî‚îÄ‚îÄ turnosStore.ts      # Estado global de turnos (fuente √∫nica de verdad)\r\n‚îú‚îÄ‚îÄ hooks/\r\n‚îÇ   ‚îú‚îÄ‚îÄ useAppointments.ts  # CRUD de turnos (legacy, sincroniza con turnosStore)\r\n‚îÇ   ‚îú‚îÄ‚îÄ useTurnos.ts        # Hook de alto nivel para turnos (usa turnosStore)\r\n‚îÇ   ‚îú‚îÄ‚îÄ useSalons.ts        # Gesti√≥n de salones\r\n‚îÇ   ‚îú‚îÄ‚îÄ useClients.ts       # Gesti√≥n de clientes\r\n‚îÇ   ‚îú‚îÄ‚îÄ useEmployees.ts     # Gesti√≥n de empleados\r\n‚îÇ   ‚îú‚îÄ‚îÄ useSalonEmployees.ts # Asignaciones sal√≥n-empleado\r\n‚îÇ   ‚îú‚îÄ‚îÄ useSalonServices.ts # Servicios por sal√≥n\r\n‚îÇ   ‚îú‚îÄ‚îÄ useServices.ts      # Servicios globales\r\n‚îÇ   ‚îî‚îÄ‚îÄ useCommissions.ts   # C√°lculo de comisiones\r\n‚îú‚îÄ‚îÄ lib/\r\n‚îÇ   ‚îú‚îÄ‚îÄ supabase.ts         # Cliente Supabase (con modo demo)\r\n‚îÇ   ‚îú‚îÄ‚îÄ employeeValidator.ts # Validaciones de empleados (regla de oro)\r\n‚îÇ   ‚îú‚îÄ‚îÄ contextValidator.ts  # Validaci√≥n de contexto front/back\r\n‚îÇ   ‚îú‚îÄ‚îÄ contextStateManager.ts # Gesti√≥n de estado durante transiciones\r\n‚îÇ   ‚îú‚îÄ‚îÄ appointmentValidator.ts # Validaci√≥n de reglas de negocio\r\n‚îÇ   ‚îú‚îÄ‚îÄ operationValidator.ts   # Orquestador de validaciones\r\n‚îÇ   ‚îú‚îÄ‚îÄ permissionResolver.ts  # RBAC - matriz rol √ó operaci√≥n\r\n‚îÇ   ‚îú‚îÄ‚îÄ demoAdapter.ts         # Demo que valida igual a real\r\n‚îÇ   ‚îú‚îÄ‚îÄ theme.ts            # Temas y estilos\r\n‚îÇ   ‚îú‚îÄ‚îÄ demoData.ts         # Datos de ejemplo\r\n‚îÇ   ‚îî‚îÄ‚îÄ uuid.ts             # Validaci√≥n de UUIDs\r\n‚îú‚îÄ‚îÄ components/\r\n‚îÇ   ‚îú‚îÄ‚îÄ views/              # Vistas principales (8 files)\r\n‚îÇ   ‚îú‚îÄ‚îÄ sections/           # Secciones complementarias\r\n‚îÇ   ‚îú‚îÄ‚îÄ features/           # Features complejos\r\n‚îÇ   ‚îú‚îÄ‚îÄ ui/                 # Componentes UI sin estado\r\n‚îÇ   ‚îî‚îÄ‚îÄ empty-states/       # Estados vac√≠os\r\n‚îú‚îÄ‚îÄ demo/\r\n‚îÇ   ‚îú‚îÄ‚îÄ constants.ts        # Banderas de demo\r\n‚îÇ   ‚îî‚îÄ‚îÄ store.ts            # Mock data para modo demo\r\n‚îú‚îÄ‚îÄ types/\r\n‚îÇ   ‚îî‚îÄ‚îÄ index.ts            # Tipos compartidos\r\n‚îî‚îÄ‚îÄ styles/\r\n    ‚îú‚îÄ‚îÄ globals.css         # Estilos globales\r\n    ‚îî‚îÄ‚îÄ index.css           # CSS principal\r\n```\r\n\r\n---\r\n\r\n## üîê Autenticaci√≥n - AuthContext.tsx\r\n\r\n### Funcionalidad Principal\r\n- **Gesti√≥n de sesi√≥n**: Login, signup, logout, reset password\r\n- **Almacenamiento seguro**: localStorage con try-catch para SSR safety\r\n- **Modo demo**: Simula usuarios sin hacer requests reales\r\n- **Membres√≠as**: Roles por organizaci√≥n (owner, admin, employee, viewer)\r\n\r\n### Flujo Clave\r\n```\r\nUser Login ‚Üí Supabase Auth ‚Üí Obtener membres√≠as ‚Üí Seleccionar org\r\n   ‚Üì\r\nAuthContext actualiza: user, session, currentOrgId, currentRole\r\n   ‚Üì\r\nApp.tsx re-renderiza con acceso a datos autenticados\r\n```\r\n\r\n### M√©todos Principales\r\n- `signIn(email, password)` ‚Üí Login con Supabase Auth\r\n- `signUp(email, password, token)` ‚Üí Registro con token de invitaci√≥n\r\n- `switchOrganization(org_id)` ‚Üí Cambiar organizaci√≥n actual\r\n- `claimInvitation(token)` ‚Üí Aceptar invitaci√≥n a organizaci√≥n\r\n\r\n### LocalStorage Keys\r\n- `sb-session` ‚Üí Sesi√≥n de Supabase\r\n- `sb-current-org` ‚Üí Organizaci√≥n seleccionada\r\n- `sb-selected-salon` ‚Üí Sal√≥n seleccionado\r\n\r\n---\r\n\r\n## üì° Cliente Supabase - lib/supabase.ts\r\n\r\n### Patr√≥n Lazy Initialization\r\n- Cliente se crea solo en browser (no en SSR/build)\r\n- Proxy pattern para acceso lazy\r\n- Stubs durante SSR para evitar errores\r\n\r\n### Modo Demo\r\n```javascript\r\nif (isDemoMode) {\r\n  // Retorna stub que simula API sin requests reales\r\n  // Usado para desarrollo/testing sin backend\r\n}\r\n```\r\n\r\n### Admin Client\r\n- `createAdminSupabaseClient()` ‚Üí Cliente con service role key\r\n- Para scripts (invitaciones, reset password, etc)\r\n\r\n---\r\n\r\n## üé£ Hooks - Acceso a Datos\r\n\r\n### useTurnos(salonId?, options?) ‚≠ê NUEVO - Hook Principal\r\n**Responsabilidad**: API simplificada para gesti√≥n de turnos (usar este en lugar de useAppointments)\r\n\r\n```javascript\r\n// Hook de alto nivel que consume turnosStore\r\nconst { \r\n  turnos,           // Lista filtrada de turnos\r\n  loading,          // Estado de carga\r\n  filters,          // Filtros actuales\r\n  setFilters,       // Cambiar filtros\r\n  createTurno,      // Crear turno\r\n  updateTurno,      // Actualizar turno\r\n  deleteTurno,      // Eliminar turno\r\n  turnosByDate,     // Selector por fecha\r\n  turnosByStatus,    // Selector por estado\r\n  validateTurno,    // Validar turno\r\n  checkConflicts    // Detectar conflictos\r\n} = useTurnos(salonId);\r\n```\r\n\r\n**Features**:\r\n- Consume `turnosStore` (fuente √∫nica de verdad)\r\n- Selectores listos para usar\r\n- Validaciones integradas\r\n- Sincronizaci√≥n con `useAppointments` durante migraci√≥n\r\n\r\n### useAppointments(salonId?, options?) ‚ö†Ô∏è LEGACY\r\n**Responsabilidad**: CRUD de turnos (mantenido para compatibilidad, sincroniza con turnosStore)\r\n\r\n```javascript\r\n// Obtiene turnos filtrados por sal√≥n/organizaci√≥n\r\nconst { appointments, loading, createAppointment, updateAppointment, deleteAppointment } = useAppointments(salonId);\r\n\r\n// Mapea formato DB ‚Üí UI:\r\n// DB: { starts_at: \"2025-10-30T14:30:00\" }\r\n// UI: { date: \"2025-10-30\", time: \"14:30\" }\r\n```\r\n\r\n**Features**:\r\n- Suscripci√≥n realtime a cambios\r\n- Validaci√≥n de UUIDs\r\n- Fallback a demo store\r\n- **Sincroniza autom√°ticamente con `turnosStore`**\r\n\r\n### useSalons(orgId?, options?)\r\n**Responsabilidad**: Gesti√≥n de salones\r\n\r\n```javascript\r\n// Obtiene salones de la organizaci√≥n\r\nconst { salons, loading, createSalon, updateSalon } = useSalons(currentOrgId);\r\n\r\n// Mapea servicios asociados a cada sal√≥n\r\n```\r\n\r\n### useClients(salonId?, options?)\r\n**Responsabilidad**: Gesti√≥n de clientes\r\n\r\n```javascript\r\n// Obtiene clientes del sal√≥n/org\r\n// Usado en ClientsView para listar y administrar clientes\r\n```\r\n\r\n### useEmployees(orgId?, options?)\r\n**Responsabilidad**: Gesti√≥n de empleados (organizaci√≥n completa)\r\n\r\n```javascript\r\n// Obtiene empleados de la organizaci√≥n\r\n// Filtra autom√°ticamente empleados sin user_id (regla de oro)\r\nconst { employees, loading, createEmployee, updateEmployee } = useEmployees(orgId);\r\n```\r\n\r\n**Regla de Oro**: Empleado = Usuario autenticado. No existe empleado sin `user_id`.\r\n\r\n### useSalonEmployees(salonId?)\r\n**Responsabilidad**: Asignaciones sal√≥n-empleado (many-to-many)\r\n\r\n```javascript\r\n// Obtiene empleados asignados a un sal√≥n\r\nconst { salonEmployees, loading, assignEmployee, unassignEmployee } = useSalonEmployees(salonId);\r\n```\r\n\r\n**Features**:\r\n- Gesti√≥n de asignaciones activas/inactivas\r\n- Validaci√≥n de empleado activo antes de asignar\r\n- Integrado con `employeeValidator`\r\n\r\n### useSalonServices(salonId?)\r\n**Responsabilidad**: Servicios espec√≠ficos de un sal√≥n\r\n\r\n```javascript\r\n// Obtiene servicios del sal√≥n con precios/duraciones\r\n```\r\n\r\n### Patr√≥n Com√∫n\r\n```javascript\r\n- State: [data, loading, error]\r\n- useEffect: fetch al montar o cuando dependencias cambian\r\n- useCallback: funciones CRUD memoizadas\r\n- Suscripci√≥n realtime a cambios en BD\r\n- Fallback a demoStore si isDemo\r\n```\r\n\r\n---\r\n\r\n## üé® Componentes - Arquitectura\r\n\r\n### views/ (Vistas Principales - 8 componentes)\r\n```\r\nHomeView.tsx              # Dashboard principal (calendario + resumen)\r\nFinancesView.tsx          # Reportes de finanzas\r\nOrganizationView.tsx      # Configuraci√≥n de organizaci√≥n\r\nSalonsManagementView.tsx  # Gesti√≥n de salones\r\nProfileView.tsx           # Perfil de usuario\r\nSettingsView.tsx          # Configuraci√≥n de la app\r\nLoginView.tsx             # P√°gina de login\r\nResetPasswordPage.tsx     # Reset de contrase√±a\r\n```\r\n\r\n### sections/ (Secciones Complementarias - 2 componentes)\r\n```\r\nClientsView.tsx           # Gesti√≥n de clientes (tabla, filtros)\r\nEmployeesView.tsx         # Gesti√≥n de empleados\r\n```\r\n\r\n### features/ (Componentes Complejos Reutilizables)\r\n\r\n#### appointments/ - Gesti√≥n de turnos\r\n```\r\nAppointmentCard.tsx       # Card para mostrar turno\r\nAppointmentDialog.tsx     # Modal crear/editar turno\r\nAppointmentActionBar.tsx  # Acciones r√°pidas (completar, cancelar)\r\n```\r\n\r\n**Flujo**:\r\n1. Calendar muestra AppointmentCard\r\n2. Click en card ‚Üí abre AppointmentDialog\r\n3. Llena formulario ‚Üí createAppointment hook\r\n4. AppointmentActionBar para cambiar estado\r\n\r\n#### finances/ - Reportes financieros\r\n```\r\nFinancesCharts.tsx        # Gr√°ficos (BarChart, AreaChart, PieChart)\r\n```\r\n\r\n**Usos**:\r\n- Ingresos por servicio (pie chart)\r\n- Ingresos por d√≠a (area chart)\r\n- Revenue trend (bar chart)\r\n\r\n### ui/ (49 componentes base sin estado)\r\n```\r\nbutton.tsx, card.tsx, badge.tsx, dialog.tsx, form.tsx, input.tsx, etc.\r\n```\r\n\r\n### generic/ (Componentes reutilizables con estado)\r\n```\r\nCalendarView.tsx          # Calendario mes actual\r\nFilterBar.tsx             # Filtros (por sal√≥n, estado, etc)\r\nGenericActionBar.tsx      # Acciones gen√©ricas\r\nTurnosPanel.tsx           # Panel de turnos del d√≠a\r\nClientsPanel.tsx          # Panel de clientes recientes\r\nServicesPanel.tsx         # Panel de servicios\r\n```\r\n\r\n---\r\n\r\n## üß† Estado Global de Turnos - turnosStore\r\n\r\n### Responsabilidad\r\n**Fuente √∫nica de verdad** para toda la l√≥gica de turnos.\r\n\r\n### Estructura\r\n```typescript\r\nturnosStore = {\r\n  turnos: Turno[],           // Lista completa de turnos\r\n  loading: boolean,          // Estado de carga\r\n  lastSyncedAt: number,      // √öltima sincronizaci√≥n\r\n  filters: {\r\n    date: 'all' | 'today' | 'week' | 'month',\r\n    status: 'all' | AppointmentStatus,\r\n    salonId: 'all' | string,\r\n    employeeId: 'all' | string,\r\n    searchQuery: string\r\n  },\r\n  selectedSalon: string | null,\r\n  \r\n  // Acciones\r\n  setAll(list: Turno[]),     // Sincronizar lista completa\r\n  upsert(turno: Turno),      // Crear o actualizar\r\n  remove(id: string),         // Eliminar\r\n  updateStatus(id, status),  // Cambiar estado\r\n  setFilters(filters),       // Actualizar filtros\r\n  setSelectedSalon(id),      // Cambiar sal√≥n seleccionado\r\n  \r\n  // Selectores\r\n  getFiltered(),             // Lista filtrada\r\n  getByDate(date),           // Por fecha\r\n  getByStatus(status),       // Por estado\r\n  getBySalon(salonId),       // Por sal√≥n\r\n  getByEmployee(empId),      // Por empleado\r\n  \r\n  // Validaciones\r\n  validateTurno(turno),      // Validar reglas de negocio\r\n  checkConflicts(turno),     // Detectar conflictos horarios\r\n  validateEmployeeInSalon(empId, salonId) // Validar asignaci√≥n\r\n}\r\n```\r\n\r\n### Patr√≥n de Uso\r\n```typescript\r\n// En componentes: usar useTurnos (recomendado)\r\nconst { turnos, createTurno, updateTurno } = useTurnos(salonId);\r\n\r\n// En hooks: sincronizar con turnosStore\r\nuseAppointments() ‚Üí turnosStore.setAll(appointments);\r\n```\r\n\r\n---\r\n\r\n## üåç App.tsx - Orquestador Principal\r\n\r\n### Responsabilidades\r\n1. **Routing**: Lazy load vistas seg√∫n tab seleccionado\r\n2. **Estado global**: Usa `useTurnos` para turnos (fuente √∫nica de verdad)\r\n3. **Interacciones**: Crear turno, cambiar sal√≥n, etc (v√≠a `useTurnos`)\r\n4. **UI layout**: Navbar, sidebar, main content\r\n\r\n### Flujo Render\r\n```\r\nApp.tsx\r\n‚îú‚îÄ‚îÄ AuthProvider (context)\r\n‚îú‚îÄ‚îÄ Navbar (usuario, sal√≥n, navegaci√≥n)\r\n‚îú‚îÄ‚îÄ Sidebar (tabs: home, clientes, finanzas, etc)\r\n‚îú‚îÄ‚îÄ MainContent (lazy carga vista seg√∫n tab)\r\n‚îÇ   ‚îú‚îÄ‚îÄ HomeView (default)\r\n‚îÇ   ‚îú‚îÄ‚îÄ ClientsView\r\n‚îÇ   ‚îú‚îÄ‚îÄ FinancesView\r\n‚îÇ   ‚îî‚îÄ‚îÄ ...\r\n‚îú‚îÄ‚îÄ AppointmentDialog (modal global para crear turno)\r\n‚îú‚îÄ‚îÄ FloatingQuickActions (botones r√°pidos)\r\n‚îú‚îÄ‚îÄ FilterBar (filtros globales)\r\n‚îú‚îÄ‚îÄ ThemeBubble (toggle dark/light)\r\n‚îî‚îÄ‚îÄ Sonner (notificaciones toast)\r\n```\r\n\r\n### Estado Principal\r\n```javascript\r\ncurrentTab = \"home\" | \"clients\" | \"finances\" | \"settings\" | ...\r\nselectedSalon = string | null\r\n\r\n// Turnos ahora vienen de useTurnos (que consume turnosStore)\r\nconst { turnos, createTurno, updateTurno, deleteTurno } = useTurnos(selectedSalon);\r\n\r\nsalons = Salon[]\r\ncurrentUser = User\r\n```\r\n\r\n---\r\n\r\n## üìä Demo Store - demo/store.ts\r\n\r\n### Prop√≥sito\r\nMock data para modo demo sin backend\r\n\r\n### Estructura\r\n```javascript\r\ndemoStore = {\r\n  appointments: { list, create, update, delete },\r\n  salons: { list, create, update },\r\n  services: { list, create },\r\n  clients: { list, create },\r\n  employees: { list, create },\r\n  organization: { get }\r\n}\r\n```\r\n\r\n### Activaci√≥n\r\n```\r\nNEXT_PUBLIC_DEMO_MODE=true npm run dev\r\n```\r\n\r\n---\r\n\r\n## üîÑ Flujos Principales\r\n\r\n### 1Ô∏è‚É£ Crear Turno\r\n```\r\nClick \"Nuevo Turno\"\r\n  ‚Üì\r\nAppointmentDialog se abre\r\n  ‚Üì\r\nLlenar: cliente, servicio, empleado, fecha, hora\r\n  ‚Üì\r\nuseTurnos().validateTurno() ‚Üí valida reglas de negocio\r\n  ‚Üì\r\nuseTurnos().checkConflicts() ‚Üí detecta conflictos horarios\r\n  ‚Üì\r\nuseTurnos().createTurno()\r\n  ‚Üì\r\nturnosStore.upsert() ‚Üí actualiza estado global\r\n  ‚Üì\r\nuseAppointments().createAppointment() ‚Üí inserta en Supabase\r\n  ‚Üì\r\nRealtime subscription notifica actualizaci√≥n\r\n  ‚Üì\r\nturnosStore.setAll() ‚Üí sincroniza con BD\r\n  ‚Üì\r\nCalendarView se re-renderiza (consume turnosStore v√≠a useTurnos)\r\n```\r\n\r\n### 2Ô∏è‚É£ Login\r\n```\r\nLoginView: email + password\r\n  ‚Üì\r\nAuthContext.signIn()\r\n  ‚Üì\r\nsupabase.auth.signInWithPassword()\r\n  ‚Üì\r\nObtener membres√≠as del usuario\r\n  ‚Üì\r\nSeleccionar organizaci√≥n default\r\n  ‚Üì\r\nlocalStorage guardar sesi√≥n\r\n  ‚Üì\r\nRouter ‚Üí /dashboard\r\n```\r\n\r\n### 3Ô∏è‚É£ Cambiar Sal√≥n\r\n```\r\nSalonCarousel click\r\n  ‚Üì\r\nonSelectSalon()\r\n  ‚Üì\r\nApp.tsx: setSelectedSalon()\r\n  ‚Üì\r\nturnosStore.setSelectedSalon() ‚Üí actualiza estado global\r\n  ‚Üì\r\nuseAppointments(selectedSalon) re-fetch\r\n  ‚Üì\r\nturnosStore.setAll() ‚Üí sincroniza turnos del nuevo sal√≥n\r\n  ‚Üì\r\nuseSalons() re-fetch\r\n  ‚Üì\r\nUI actualiza con datos del sal√≥n (consume turnosStore v√≠a useTurnos)\r\n```\r\n\r\n### 4Ô∏è‚É£ Asignar Empleado a Sal√≥n\r\n```\r\nSalonsManagementView: Editar sal√≥n\r\n  ‚Üì\r\nuseEmployees() ‚Üí carga empleados de la organizaci√≥n\r\n  ‚Üì\r\nuseSalonEmployees(salonId) ‚Üí carga asignaciones actuales\r\n  ‚Üì\r\nUI muestra checkboxes con empleados disponibles\r\n  ‚Üì\r\nUsuario marca/desmarca empleados\r\n  ‚Üì\r\nhandleSave() compara asignaciones actuales vs seleccionadas\r\n  ‚Üì\r\nassignEmployee() / unassignEmployee() ‚Üí actualiza tabla salon_employees\r\n  ‚Üì\r\nValidaci√≥n: employeeValidator valida que empleado tenga user_id\r\n```\r\n\r\n---\r\n\r\n## üì± UI Pattern - Componentes Reutilizables\r\n\r\n### Estructura T√≠pica\r\n```tsx\r\n// Componente funcional con props tipadas\r\ninterface Props {\r\n  data: T[];\r\n  loading: boolean;\r\n  onSelect: (item: T) => void;\r\n}\r\n\r\nexport function MyComponent({ data, loading, onSelect }: Props) {\r\n  return (\r\n    <div>\r\n      {loading ? <Skeleton /> : data.map(...)}\r\n    </div>\r\n  );\r\n}\r\n```\r\n\r\n### Lazy Loading en Vistas\r\n```tsx\r\nconst HomeView = lazy(() => import(\"./components/views/HomeView\"));\r\n\r\n// En JSX:\r\n<Suspense fallback={<LoadingState />}>\r\n  <HomeView {...props} />\r\n</Suspense>\r\n```\r\n\r\n---\r\n\r\n## üîí RLS (Row Level Security)\r\n\r\n### Principio\r\nLos datos se filtran autom√°ticamente por `org_id` en la BD\r\n\r\n```sql\r\n-- Ejemplo: SELECT * FROM appointments WHERE org_id = current_user.org_id\r\n```\r\n\r\n### En Hooks\r\n```javascript\r\n// useAppointments hace:\r\nconst { data } = await supabase\r\n  .from('appointments')\r\n  .select()\r\n  .eq('salon_id', salonId)  // Filtro adicional UI-side\r\n  // RLS en BD verifica org_id autom√°ticamente\r\n```\r\n\r\n---\r\n\r\n## üõ†Ô∏è Patrones Usados\r\n\r\n### 1. Custom Hooks para Datos\r\n- useAppointments, useSalons, useClients, etc.\r\n- Encapsulan fetch + estado + suscripci√≥n realtime\r\n- Reutilizables en m√∫ltiples componentes\r\n\r\n### 2. Context para Auth Global\r\n- AuthContext proporciona usuario, sesi√≥n, org actual\r\n- Consumido por useAuth() hook\r\n\r\n### 3. Lazy Loading + Suspense\r\n- Vistas se cargan solo cuando se seleccionan\r\n- Reduce bundle initial size\r\n\r\n### 4. Componentes Memoizados\r\n- AppointmentCard usa React.memo\r\n- Evita re-renders innecesarios\r\n\r\n### 5. Realtime Subscriptions\r\n- useAppointments se suscribe a cambios\r\n- Actualizaci√≥n instant√°nea en m√∫ltiples tabs\r\n\r\n### 6. Demo Mode\r\n- Misma interfaz funciona con o sin Supabase\r\n- demoStore simula API\r\n\r\n---\r\n\r\n## üöÄ Flujo Inicio de Sesi√≥n\r\n\r\n1. **Usuario entra a /** ‚Üí protegido por AuthProvider\r\n2. **No logueado?** ‚Üí Redirect a LoginView\r\n3. **Ingresa credenciales** ‚Üí signIn(email, password)\r\n4. **Supabase Auth** ‚Üí Genera JWT, actualiza sesi√≥n\r\n5. **Obtener membres√≠as** ‚Üí SELECT FROM memberships WHERE user_id = ?\r\n6. **Seleccionar org** ‚Üí currentOrgId = memberships[0].org_id\r\n7. **localStorage** ‚Üí Guardar sesi√≥n para persistencia\r\n8. **Redirect** ‚Üí /dashboard\r\n9. **App cargado** ‚Üí Mostrar HomeView\r\n\r\n---\r\n\r\n## üìö Tipos Principales (src/types/index.ts)\r\n\r\n```typescript\r\nUser {\r\n  id: string\r\n  email?: string\r\n  memberships: Membership[]  // Roles por org\r\n  current_org_id?: string\r\n}\r\n\r\nMembership {\r\n  org_id: string\r\n  role: 'owner' | 'admin' | 'employee' | 'viewer'\r\n  is_primary?: boolean\r\n}\r\n\r\nTurno {\r\n  id: string\r\n  clientName: string\r\n  service: string\r\n  date: string        // YYYY-MM-DD\r\n  time: string        // HH:mm\r\n  status: 'pending' | 'confirmed' | 'completed' | 'cancelled'\r\n  stylist: string\r\n  salonId: string\r\n  notes?: string\r\n  created_by?: string\r\n  total_amount?: number\r\n}\r\n\r\nAppointment {\r\n  // Similar a Turno pero con campos adicionales para compatibilidad\r\n  // Migraci√≥n gradual: componentes usan Turno, algunos usan Appointment\r\n}\r\n\r\nEmployee {\r\n  id: string\r\n  org_id: string\r\n  user_id: string     // OBLIGATORIO - regla de oro\r\n  full_name: string\r\n  email?: string\r\n  phone?: string\r\n  default_commission_pct?: number\r\n  active: boolean\r\n  deleted_at?: string | null\r\n}\r\n\r\nSalonEmployee {\r\n  id: string\r\n  salon_id: string\r\n  employee_id: string\r\n  active: boolean\r\n  created_at: string\r\n  updated_at: string\r\n}\r\n\r\nSalon {\r\n  id: string\r\n  org_id: string\r\n  name: string\r\n  address: string\r\n  phone?: string\r\n  // staff: string[] ELIMINADO - ahora usa salon_employees\r\n  services?: Service[]\r\n}\r\n\r\nService {\r\n  id: string\r\n  name: string\r\n  base_price: number\r\n  duration_minutes: number\r\n}\r\n```\r\n\r\n---\r\n\r\n## üéØ Decisiones de Dise√±o\r\n\r\n### ‚úÖ Por qu√© Supabase?\r\n- PostgreSQL + Auth + Realtime\r\n- RLS nativo para multi-tenant\r\n- Pricing flexible\r\n\r\n### ‚úÖ Por qu√© Next.js?\r\n- SSR para performance\r\n- API routes para backend\r\n- File-based routing\r\n\r\n### ‚úÖ Por qu√© Lazy Loading?\r\n- Reduce bundle size\r\n- Mejor UX inicial\r\n- Preload inteligente\r\n\r\n### ‚úÖ Por qu√© Demo Mode?\r\n- Develop sin configurar BD\r\n- Demostraci√≥n sin credenciales\r\n- Testing en producci√≥n\r\n\r\n---\r\n\r\n## üîó Dependencias Cr√≠ticas\r\n\r\n- `@supabase/supabase-js` - Cliente API\r\n- `next` - Framework\r\n- `react` - UI\r\n- `shadcn/ui` - Componentes base (49 files)\r\n- `lucide-react` - Iconos\r\n- `sonner` - Notificaciones toast\r\n\r\n---\r\n\r\n## üìù Summary para Prompts Futuros\r\n\r\n> \"Coreboard es un CRM multi-org para salones. Auth v√≠a Supabase, datos con RLS, modo demo sin BD. Arquitectura: App.tsx (shell) ‚Üí AuthContext (sesi√≥n) ‚Üí turnosStore (estado global) ‚Üí useTurnos (hook principal) ‚Üí Views (UI). Turnos: CalendarView ‚Üí AppointmentCard ‚Üí AppointmentDialog ‚Üí useTurnos().createTurno() ‚Üí turnosStore.upsert(). Empleados: useEmployees() + useSalonEmployees() con validaci√≥n de user_id obligatorio. Clientes, Finanzas en otras vistas. RLS filtra autom√°ticamente por org_id. Lazy load vistas. Realtime subs en cambios. turnosStore es la fuente √∫nica de verdad para turnos.\"\r\n\r\n---\r\n\r\n## ‚ö†Ô∏è TENSIONES L√ìGICAS Y ASIMETR√çAS (CR√çTICO)\r\n\r\n### El modelo mental propuesto\r\n\r\n```\r\nuser\r\n  ‚îî‚îÄ‚îÄ org (currentOrgId - localStorage)\r\n       ‚îî‚îÄ‚îÄ salon (selectedSalon - localStorage)\r\n            ‚îú‚îÄ‚îÄ appointments\r\n            ‚îú‚îÄ‚îÄ clients\r\n            ‚îú‚îÄ‚îÄ employees\r\n            ‚îî‚îÄ‚îÄ salonServices\r\n```\r\n\r\n**Es l√≥gico. Pero NO es neutral.** Implica decisiones que tienen consecuencias.\r\n\r\n---\r\n\r\n### Tensi√≥n #1: Dos Fuentes de Verdad para \"org actual\"\r\n\r\n**El problema:**\r\n```\r\nFrontend (localStorage):\r\n  currentOrgId = \"org-123\"  ‚Üê Qu√© CREE que est√° viendo\r\n\r\nBackend (RLS):\r\n  auth.uid() + memberships ‚Üí \"org-456\"  ‚Üê Qu√© PUEDE ver en realidad\r\n\r\nSupabase gana. RLS filtra.\r\n```\r\n\r\n**La consecuencia:**\r\n- Tu UI puede mostrar \"mostrando org-123\"\r\n- Los hooks vuelven lista vac√≠a\r\n- **Esto es V√ÅLIDO seg√∫n tu arquitectura**\r\n- Pero es un estado raro que no est√° documentado\r\n\r\n**Es l√≥gico**: Aceptas incoherencia de estado. Est√° permitido.\r\n**Lo honesto**: \"El front NO puede asumir que localStorage es v√°lido\".\r\n\r\n---\r\n\r\n### Tensi√≥n #2: Condiciones de Carrera Suaves\r\n\r\n**El flujo te√≥rico:**\r\n```\r\nUser cambia sal√≥n\r\n  ‚Üì\r\nsetSelectedSalon(\"salon-B\")\r\n  ‚Üì\r\nuseAppointments(\"salon-B\") fetch\r\n  ‚Üì\r\nAuthContext actualiza org\r\n```\r\n\r\n**El flujo real (posible):**\r\n```\r\nsetSelectedSalon(\"salon-B\")\r\n  ‚Üì\r\nuseAppointments(\"salon-B\") hace fetch con contexto viejo\r\n  ‚Üì\r\n[200ms de espera]\r\n  ‚Üì\r\nAuthContext actualiza org\r\n  ‚Üì\r\nuseAppointments vuelve a subscribirse\r\n```\r\n\r\n**La consecuencia:**\r\n- Render con datos \"stale\" pero no inv√°lidos\r\n- No rompe, pero existe\r\n- Cada hook se sincroniza solo ‚Üí inconsistencia temporal\r\n\r\n**Es l√≥gico**: Es consecuencia de tener sincronizaci√≥n por recurso en lugar de por contexto.\r\n\r\n---\r\n\r\n### Tensi√≥n #3: Roles Binarios vs Features Granulares\r\n\r\n**Tu modelo dice:**\r\n```\r\nRoles = owner | admin | employee | viewer\r\nAplicado por: \"pertenezco a esta org\"\r\n```\r\n\r\n**Pero luego agreg√°s:**\r\n```\r\nFinanzas (¬øpuedo ver ingresos?)\r\nComisiones (¬øpuedo ver mis comisiones?)\r\nOperaciones sensibles (¬øpuedo crear turnos?)\r\n```\r\n\r\n**La inconsistencia:**\r\n- El modelo de roles es **binario por org**\r\n- Las features necesitan **granularidad por tipo de dato**\r\n- Tu RLS probablemente dice: `WHERE org_id = current_user_org_id`\r\n- Pero tus permisos de negocio dicen: `IF role = 'employee' THEN no_finanzas`\r\n\r\n**Es l√≥gico**: El modelo es extensible pero incompleto.\r\n**Lo honesto**: \"Ten√©s un modelo de autorizaci√≥n de dos niveles que no est√°n sincronizados\".\r\n\r\n---\r\n\r\n### Tensi√≥n #4: Demo vs Real - RLS Invisible\r\n\r\n**Tu demanda:**\r\n```\r\nDemo mode: misma interfaz, datos mock\r\nReal mode: misma interfaz, datos Supabase\r\n```\r\n\r\n**Lo que pas√°:**\r\n```\r\nDemo:\r\n  const data = demoStore.appointments.list()\r\n  // Devuelve lista sin filtro RLS\r\n  // El frontend ve \"funciona perfecto\"\r\n\r\nReal:\r\n  const data = supabase.from('appointments').select()\r\n  // RLS filtra por org_id\r\n  // El frontend ve \"funciona perfecto\"\r\n  \r\nPERO: En demo nunca alguien intenta ver org ajena.\r\n     En real s√≠, y RLS lo bloquea.\r\n```\r\n\r\n**La asimetr√≠a:**\r\n- Tu \"contrato l√≥gico\" es: \"mismo hook, mismo formato\"\r\n- Tu \"seguridad l√≥gica\" es: diferente (demo sin RLS, real con RLS)\r\n- El test que pas√° en demo puede fallar en real\r\n\r\n**Es l√≥gico**: La abstracci√≥n (hook) es isom√≥rfica.\r\n**Lo honesto**: \"La seguridad entre ambientes es diferente\".\r\n\r\n---\r\n\r\n### Tensi√≥n #5: Validaci√≥n de Negocio Faltante\r\n\r\n**Tu modelo de turnos:**\r\n```\r\nabro modal\r\n  ‚Üì\r\nelijo cliente/servicio/empleado/fecha/hora\r\n  ‚Üì\r\nhook.createAppointment()\r\n  ‚Üì\r\ninserta en Supabase\r\n```\r\n\r\n**Lo que NO validas:**\r\n```\r\n¬øEste empleado hace este servicio?\r\n¬øEste horario no est√° ocupado?\r\n¬øEl sal√≥n abre ese d√≠a?\r\n¬øEl cliente tiene este servicio en su historial?\r\n¬øEl empleado est√° disponible?\r\n```\r\n\r\n**Tu sistema hoy dice:**\r\n```\r\n\"Todo turno con salon_id v√°lido es v√°lido\"\r\n```\r\n\r\n**El negocio real dice:**\r\n```\r\n\"Un turno v√°lido es uno que:\r\n  - asigna un servicio que el sal√≥n tiene\r\n  - a un empleado que lo hace\r\n  - en un horario que est√° libre\r\n  - en un sal√≥n que abre\r\n  - a un cliente que existe\"\r\n```\r\n\r\n**Es l√≥gico**: Acept√°s turnos \"crudos\" sin reglas de negocio.\r\n**Lo honesto**: \"Hoy valid√°s identidad pero no l√≥gica\".\r\n\r\n---\r\n\r\n### Tensi√≥n #6: Realtime por Recurso = Estados Intermedios Raros\r\n\r\n**Tu arquitectura:**\r\n```\r\nuseAppointments ‚Üí subscripci√≥n A\r\nuseSalons ‚Üí subscripci√≥n B\r\nuseClients ‚Üí subscripci√≥n C\r\n```\r\n\r\n**El escenario:**\r\n```\r\nUser cambia de sal√≥n\r\n  ‚Üì\r\nsetSelectedSalon(\"salon-B\")\r\n  ‚Üì\r\nuseAppointments(\"salon-B\") re-fetch [200ms]\r\n  ‚Üì\r\nUI renderiza: salon = B, appointments = [viejo de A], clientes = [viejo de A]\r\n  ‚Üì\r\n[200ms despu√©s] useClients re-fetch completa\r\n  ‚Üì\r\nUI renderiza: salon = B, appointments = [nuevo de B], clientes = [nuevo de B]\r\n```\r\n\r\n**Resultado:**\r\n- 200ms mirando datos de dos salones distintos\r\n- V√°lido pero cognitivamente disonante\r\n\r\n**Es l√≥gico**: Cada recurso se sincroniza solo.\r\n**Lo honesto**: \"Admit√≠s estados intermedios donde la UI es internamente inconsistente\".\r\n\r\n---\r\n\r\n### Tensi√≥n #7: App.tsx es un √önico Punto de Fallo\r\n\r\n**Tu centralizaci√≥n:**\r\n```\r\nApp.tsx sabe:\r\n  - user\r\n  - org\r\n  - salon\r\n  - tab\r\n  \r\nTODO lo dem√°s depende de esto\r\n```\r\n\r\n**La matem√°tica:**\r\n```\r\nSi App.tsx falla     ‚Üí todo falla igual\r\nSi App.tsx tarda     ‚Üí todo tarda igual\r\nSi App.tsx calcula mal ‚Üí todo ve lo mismo mal\r\n```\r\n\r\n**Es l√≥gico**: Centralizaci√≥n = consistencia fuerte.\r\n**Lo honesto**: \"Tu robustez est√° acoplada a un √∫nico componente\".\r\n\r\n---\r\n\r\n### Tensi√≥n #8: Doble Llave de Organizaci√≥n\r\n\r\n**Frontend:**\r\n```\r\ncurrentOrgId = localStorage.getItem('sb-current-org')\r\n```\r\n\r\n**Backend:**\r\n```\r\nRLS: WHERE org_id IN (\r\n  SELECT org_id FROM memberships \r\n  WHERE user_id = auth.uid()\r\n)\r\n```\r\n\r\n**¬øSon la misma cosa?**\r\n```\r\nNo necesariamente:\r\n\r\nCaso 1: User cambi√≥ org en la BD (admin lo movi√≥)\r\n  Front sigue viendo org-vieja\r\n  Back le muestra org-nueva\r\n  Divergencia\r\n\r\nCaso 2: localStorage se corrompi√≥\r\n  Front: org-123\r\n  Back: org-456\r\n  Divergencia\r\n\r\nCaso 3: Token expir√≥\r\n  Front: sigue pensando que est√° autenticado\r\n  Back: rechaza todo\r\n  Divergencia\r\n```\r\n\r\n**Es l√≥gico**: Son dos sistemas independientes.\r\n**Lo honesto**: \"Pueden divergir. Necesit√°s un mecanismo para detectarlo\".\r\n\r\n---\r\n\r\n## ‚úÖ Lo que S√ç cierra l√≥gicamente\r\n\r\n```\r\n‚úÖ √Årbol user ‚Üí org ‚Üí salon ‚Üí recursos\r\n   Jerarqu√≠a clara y coherente\r\n\r\n‚úÖ Hooks que dependen de contexto global\r\n   Toda operaci√≥n sabe d√≥nde est√°\r\n\r\n‚úÖ RLS como guardia final\r\n   \"Aunque el front se equivoque, vos no ves nada\"\r\n\r\n‚úÖ Demo y real con mismo contrato\r\n   La abstracci√≥n funciona en ambos lados\r\n\r\n‚úÖ Lazy loading por vistas\r\n   Reduce complejidad cognitiva\r\n```\r\n\r\n---\r\n\r\n## ‚úÖ Mejoras Recientes (Refactorizaci√≥n)\r\n\r\n### Sistema Global de Turnos\r\n- ‚úÖ **`turnosStore`**: Estado centralizado (fuente √∫nica de verdad)\r\n- ‚úÖ **`useTurnos`**: Hook de alto nivel para componentes\r\n- ‚úÖ **Validaciones integradas**: Conflictos horarios, empleados asignados, datos completos\r\n- ‚úÖ **Migraci√≥n gradual**: Componentes migrados manteniendo compatibilidad\r\n\r\n### Gesti√≥n de Empleados\r\n- ‚úÖ **`employeeValidator.ts`**: Validaciones centralizadas (user_id obligatorio)\r\n- ‚úÖ **Tabla `salon_employees`**: Asignaciones many-to-many (reemplaza array de strings)\r\n- ‚úÖ **Regla de oro**: Empleado = Usuario autenticado. No existe empleado sin `user_id`\r\n- ‚úÖ **`SalonsManagementView`**: Refactorizado para usar empleados reales con checkboxes\r\n\r\n### Componentes Migrados\r\n- ‚úÖ `App.tsx`, `AppointmentDialog.tsx`, `TurnosPanel.tsx`, `CalendarView.tsx`, `ClientsPanel.tsx`\r\n- ‚úÖ `HomeView.tsx`, `OwnerDashboard.tsx`, `ClientDashboard.tsx`, `OperationsDashboard.tsx`, `SalesMarketingDashboard.tsx`\r\n- ‚úÖ `useFinancialMetrics.ts`, `useFinancialAlerts.ts`\r\n\r\n## ‚ö†Ô∏è Lo que a√∫n est√° incompleto\r\n\r\n```\r\n‚ö†Ô∏è Roles aplicados a nivel org, pero no por recurso\r\n   Necesit√°s granularidad\r\n\r\n‚ö†Ô∏è Validaci√≥n de negocio (turnos v√°lidos) - PARCIALMENTE RESUELTO\r\n   ‚úÖ turnosStore valida conflictos y asignaciones\r\n   ‚ö†Ô∏è Falta validaci√≥n en BD (triggers)\r\n\r\n‚ö†Ô∏è Doble fuente de \"org actual\"\r\n   Pueden divergir sin detecci√≥n\r\n   ‚úÖ contextValidator existe pero no est√° integrado en todos los flujos\r\n\r\n‚ö†Ô∏è Realtime por lista\r\n   Genera estados intermedios inconsistentes\r\n   ‚úÖ turnosStore ayuda pero no elimina completamente\r\n\r\n‚ö†Ô∏è Condiciones de carrera suaves\r\n   Existen pero no son catastr√≥ficas\r\n   ‚úÖ contextStateManager ayuda pero no est√° en todos los flujos\r\n```\r\n\r\n---\r\n\r\n## üéØ La Versi√≥n Honesta\r\n\r\n**Lo que tu arquitectura ASUME:**\r\n```\r\n1. El cliente nunca manda datos inv√°lidos\r\n2. El usuario siempre est√° en la org correcta\r\n3. Las listas nunca necesitan consistencia fuerte\r\n4. El frontend y backend siempre acuerdan en org_id\r\n5. Los roles no var√≠an por tipo de dato\r\n```\r\n\r\n**La realidad del software:**\r\n```\r\nEn producci√≥n, TODAS estas cosas pasan.\r\n```\r\n\r\n---\r\n\r\n## üöÄ Qu√© Falta para Cerrar los Huecos\r\n\r\n### 1. Sincronizaci√≥n de contexto ‚ö†Ô∏è PARCIAL\r\n```javascript\r\n// ‚úÖ YA TENEMOS:\r\nturnosStore ‚Üí estado global de turnos\r\nuseTurnos ‚Üí hook unificado para turnos\r\n\r\n// ‚ö†Ô∏è FALTA:\r\nuseSalons(orgId) ‚Üí suscripci√≥n B (a√∫n independiente)\r\nuseClients(salonId) ‚Üí suscripci√≥n C (a√∫n independiente)\r\n\r\n// IDEAL:\r\nconst { turnos, salons, clients } = useOrgContext()\r\n// Una suscripci√≥n que actualiza TODO\r\n```\r\n\r\n### 2. Validaci√≥n de negocio en BD ‚ö†Ô∏è PARCIAL\r\n```sql\r\n-- ‚úÖ YA TENEMOS EN FRONTEND:\r\nturnosStore.validateTurno() ‚Üí valida conflictos\r\nturnosStore.checkConflicts() ‚Üí detecta solapamientos\r\nemployeeValidator ‚Üí valida asignaciones\r\n\r\n-- ‚ö†Ô∏è FALTA EN BD:\r\nCREATE TRIGGER validate_appointment_before_insert\r\nBEFORE INSERT ON appointments\r\nFOR EACH ROW\r\nEXECUTE FUNCTION validate_appointment_logic();\r\n-- Chequea: empleado hace servicio, horario libre, etc\r\n```\r\n\r\n### 3. Detecci√≥n de divergencia org\r\n```javascript\r\n// En AuthContext:\r\nif (localStorage_org !== jwt_org) {\r\n  // Sincronizar o rechazar\r\n  syncOrRefresh()\r\n}\r\n```\r\n\r\n### 4. Roles granulares\r\n```typescript\r\n// En lugar de:\r\nrole: 'owner' | 'admin' | 'employee' | 'viewer'\r\n\r\n// Tener:\r\npermissions: {\r\n  can_view_finances: boolean\r\n  can_create_appointment: boolean\r\n  can_view_salary: boolean\r\n  can_edit_services: boolean\r\n}\r\n```\r\n\r\n### 5. Batch updates en realtime\r\n```javascript\r\n// En lugar de:\r\nappointments.subscribe() // actualiza sola\r\nsalons.subscribe() // actualiza sola\r\nclients.subscribe() // actualiza sola\r\n\r\n// Tener:\r\ncontext.subscribe() // actualiza todo junto\r\n// O: useTransition() para agrupar renders\r\n```\r\n\r\n---\r\n\r\n## üìù Conclusi√≥n\r\n\r\nTu arquitectura no es \"mala\". Es **parcialmente especificada**.\r\n\r\n- La macro-l√≥gica (√°rbol org/salon) funciona\r\n- La micro-l√≥gica (validaci√≥n de turnos) no est√° implementada\r\n- La seguridad (RLS + frontend) est√° redundante pero no sincronizada\r\n- La sincronizaci√≥n (realtime) es correcta pero por lista\r\n\r\n**No necesitas redise√±ar. Necesit√°s completar.**\r\n\r\nEl sistema actual dice: \"Maneja orgs y salones bien, pero asume datos v√°lidos\". En MVP eso est√° bien. En producci√≥n, necesit√°s llenar esos huecos.\r\n",
  "sections": []
}