{
  "metadata": {
    "title": "Integración de Payment Links - Proceso Completo",
    "path": "docs/INTEGRACION_PAYMENT_LINKS.md",
    "category": "integration",
    "tags": [
      "integration"
    ],
    "lastUpdated": "2025-11-15",
    "fileName": "INTEGRACION_PAYMENT_LINKS"
  },
  "content": "# Integración de Payment Links - Proceso Completo\r\n\r\n## Resumen Ejecutivo\r\n\r\nEste documento detalla el proceso completo de implementación y corrección de la funcionalidad de Payment Links (links de pago públicos) en Coreboard, incluyendo los problemas encontrados, las soluciones aplicadas y el estado final del sistema.\r\n\r\n## Herramientas Utilizadas\r\n\r\n### 1. Supabase MCP (Model Context Protocol)\r\n- **Conexión**: Mediante el MCP de Supabase integrado en Cursor\r\n- **Proyecto ID**: `hawpywnmkatwlcbtffrg`\r\n- **Funciones principales utilizadas**:\r\n  - `mcp_supabase_apply_migration`: Para aplicar migraciones SQL\r\n  - `mcp_supabase_execute_sql`: Para ejecutar queries SQL directos\r\n  - `mcp_supabase_get_logs`: Para revisar logs de Edge Functions\r\n  - `mcp_supabase_list_tables`: Para verificar estructura de la base de datos\r\n  - `mcp_supabase_list_extensions`: Para verificar extensiones instaladas\r\n\r\n### 2. Supabase CLI\r\n- **Comando principal**: `npx --yes supabase functions deploy`\r\n- **Uso**: Despliegue de Edge Functions sin necesidad de tener Supabase CLI instalado localmente\r\n- **Flags importantes**:\r\n  - `--project-ref`: ID del proyecto Supabase\r\n  - `--workdir`: Directorio de trabajo\r\n  - `--no-verify-jwt`: Para funciones públicas que no requieren autenticación\r\n\r\n### 3. Browser Extension MCP\r\n- **Uso**: Para probar el flujo completo en el navegador\r\n- **URL de prueba**: `http://192.168.100.50:3000` (servidor local)\r\n- **URL de producción**: `https://coreboard.vercel.app`\r\n\r\n## Problemas Encontrados y Soluciones\r\n\r\n### Problema 1: Formato bytea para token_hash\r\n\r\n**Problema**: \r\n- La columna `token_hash` en `app.payment_links` es de tipo `bytea`\r\n- PostgREST/Supabase no puede manejar directamente `Uint8Array` desde JavaScript\r\n- Intentos de convertir a hexadecimal fallaban al insertar o buscar\r\n\r\n**Solución Aplicada**:\r\n1. Creación de función RPC `create_payment_link` en PostgreSQL que maneja el bytea directamente\r\n2. Uso de `extensions.digest()` para calcular SHA-256 hash del token\r\n3. La función RPC genera el token, calcula el hash y lo inserta en la base de datos\r\n\r\n**Código de la función RPC**:\r\n```sql\r\nCREATE OR REPLACE FUNCTION public.create_payment_link(\r\n  p_org_id uuid,\r\n  p_salon_id uuid,\r\n  p_title text DEFAULT 'Reserva tu turno',\r\n  p_description text DEFAULT NULL,\r\n  p_token text DEFAULT NULL,\r\n  p_expires_at timestamptz DEFAULT NULL,\r\n  p_metadata jsonb DEFAULT '{}'::jsonb\r\n)\r\nRETURNS json\r\nLANGUAGE plpgsql\r\nSECURITY DEFINER\r\nSET search_path = public, app, extensions, pg_catalog\r\nAS $$\r\nDECLARE\r\n  v_token text;\r\n  v_token_hash bytea;\r\n  v_expires_at timestamptz;\r\n  v_payment_link_id uuid;\r\nBEGIN\r\n  -- Generar token si no se proporciona\r\n  IF p_token IS NULL THEN\r\n    v_token := encode(extensions.gen_random_bytes(32), 'hex');\r\n  ELSE\r\n    v_token := p_token;\r\n  END IF;\r\n\r\n  -- Calcular hash SHA-256 del token\r\n  v_token_hash := extensions.digest(v_token, 'sha256');\r\n\r\n  -- ... resto de la función\r\nEND;\r\n$$;\r\n```\r\n\r\n**Migración aplicada**: `create_payment_link_rpc` (vía MCP)\r\n\r\n---\r\n\r\n### Problema 2: Extensión pgcrypto no disponible\r\n\r\n**Problema**:\r\n- La función `gen_random_bytes()` no estaba disponible\r\n- Error: `function gen_random_bytes(integer) does not exist`\r\n\r\n**Solución Aplicada**:\r\n1. Verificación de extensiones instaladas con `mcp_supabase_list_extensions`\r\n2. Habilitación de `pgcrypto` con `CREATE EXTENSION IF NOT EXISTS pgcrypto`\r\n3. Uso de `extensions.gen_random_bytes()` en lugar de `gen_random_bytes()` directamente\r\n\r\n**Migración aplicada**: `enable_pgcrypto_and_fix_create_payment_link` (vía MCP)\r\n\r\n---\r\n\r\n### Problema 3: Nombre incorrecto de tabla organizations\r\n\r\n**Problema**:\r\n- La función RPC `get_payment_link_by_token` buscaba `app.organizations`\r\n- La tabla real se llama `app.orgs`\r\n- Error: `relation \"app.organizations\" does not exist`\r\n\r\n**Solución Aplicada**:\r\n1. Verificación de estructura con `mcp_supabase_list_tables`\r\n2. Corrección de la función RPC para usar `app.orgs` en lugar de `app.organizations`\r\n\r\n**Migración aplicada**: `fix_get_payment_link_by_token_table_name` (vía MCP)\r\n\r\n---\r\n\r\n### Problema 4: Autenticación requerida en get-payment-link-config\r\n\r\n**Problema**:\r\n- La Edge Function `get-payment-link-config` requería autenticación\r\n- Error 401: \"Missing authorization header\"\r\n- Los clientes no pueden validar el token sin autenticarse primero (círculo vicioso)\r\n\r\n**Solución Aplicada**:\r\n1. Eliminación de la validación de autenticación en el código de la función\r\n2. Despliegue con flag `--no-verify-jwt` para permitir acceso público\r\n3. La validación del token es suficiente para verificar el link\r\n\r\n**Cambios en el código**:\r\n```typescript\r\n// ANTES (requería autenticación):\r\nconst authHeader = req.headers.get('Authorization');\r\nif (!authHeader || !authHeader.startsWith('Bearer ')) {\r\n  return new Response(\r\n    JSON.stringify({ error: 'Autenticación requerida...' }),\r\n    { status: 401, headers: { ...CORS_HEADERS, 'Content-Type': 'application/json' } }\r\n  );\r\n}\r\n\r\n// DESPUÉS (no requiere autenticación):\r\n// No requerir autenticación de usuario para validación inicial del token\r\n// Pero Supabase requiere un header de autorización (anon key es suficiente)\r\n// La validación del token es suficiente para verificar el link\r\n```\r\n\r\n**Comando de despliegue**:\r\n```bash\r\nnpx --yes supabase functions deploy get-payment-link-config \\\r\n  --project-ref hawpywnmkatwlcbtffrg \\\r\n  --workdir \"C:\\Users\\Matecore\\Downloads\\Coreboard\" \\\r\n  --no-verify-jwt\r\n```\r\n\r\n---\r\n\r\n### Problema 5: Headers CORS\r\n\r\n**Problema**:\r\n- Las Edge Functions no tenían headers CORS configurados\r\n- Los requests desde el frontend fallaban por CORS\r\n\r\n**Solución Aplicada**:\r\n- Agregado de headers CORS en ambas funciones:\r\n  - `create-payment-link`\r\n  - `get-payment-link-config`\r\n\r\n**Código**:\r\n```typescript\r\nconst CORS_HEADERS = {\r\n  'Access-Control-Allow-Origin': '*',\r\n  'Access-Control-Allow-Headers': 'authorization, x-client-info, apikey, content-type',\r\n};\r\n```\r\n\r\n---\r\n\r\n## Funciones RPC Creadas\r\n\r\n### 1. `public.create_payment_link`\r\n- **Propósito**: Crear un payment link con manejo correcto de bytea\r\n- **Parámetros**:\r\n  - `p_org_id`: UUID de la organización\r\n  - `p_salon_id`: UUID del salón\r\n  - `p_title`: Título del link (default: 'Reserva tu turno')\r\n  - `p_description`: Descripción (opcional)\r\n  - `p_token`: Token personalizado (opcional, se genera si no se proporciona)\r\n  - `p_expires_at`: Fecha de expiración (opcional, default: 30 días)\r\n  - `p_metadata`: Metadata JSON (opcional)\r\n- **Retorna**: JSON con `id`, `token`, `expires_at`\r\n- **Schema**: `public` (accesible desde PostgREST)\r\n\r\n### 2. `public.get_payment_link_by_token`\r\n- **Propósito**: Obtener información de un payment link por su token\r\n- **Parámetros**:\r\n  - `p_token`: Token del payment link (texto plano)\r\n- **Retorna**: JSON con toda la información del link, incluyendo `salon` y `org`\r\n- **Validaciones**:\r\n  - Calcula hash SHA-256 del token\r\n  - Busca por `token_hash` (bytea)\r\n  - Verifica que esté activo (`active = true`)\r\n  - Verifica que no haya expirado (`expires_at > now()`)\r\n\r\n---\r\n\r\n## Edge Functions Modificadas\r\n\r\n### 1. `create-payment-link`\r\n- **Estado**: ✅ Funcionando\r\n- **Cambios principales**:\r\n  - Uso de función RPC en lugar de insertar directamente\r\n  - Headers CORS agregados\r\n  - Manejo de errores mejorado\r\n\r\n### 2. `get-payment-link-config`\r\n- **Estado**: ✅ Funcionando\r\n- **Cambios principales**:\r\n  - Eliminación de requerimiento de autenticación\r\n  - Uso de función RPC para buscar por token\r\n  - Despliegue con `--no-verify-jwt`\r\n  - Headers CORS agregados\r\n\r\n---\r\n\r\n## Flujo Completo Implementado\r\n\r\n### 1. Generación de Payment Link\r\n1. Usuario hace clic en \"Generar link de pago\" en el dashboard\r\n2. Frontend llama a `/functions/v1/create-payment-link` con:\r\n   - `org_id`\r\n   - `salon_id`\r\n   - `title` (opcional)\r\n   - `description` (opcional)\r\n3. Edge Function llama a `public.create_payment_link()` RPC\r\n4. RPC genera token aleatorio (32 bytes)\r\n5. RPC calcula hash SHA-256 del token\r\n6. RPC inserta en `app.payment_links` con `token_hash` (bytea)\r\n7. RPC retorna `id`, `token`, `expires_at`\r\n8. Edge Function retorna URL completa: `https://coreboard.vercel.app/book/{token}`\r\n9. Frontend muestra el link en un modal\r\n\r\n### 2. Validación de Payment Link\r\n1. Cliente accede a `https://coreboard.vercel.app/book/{token}`\r\n2. Frontend llama a `/functions/v1/get-payment-link-config?token={token}`\r\n3. Edge Function llama a `public.get_payment_link_by_token({p_token: token})`\r\n4. RPC calcula hash SHA-256 del token recibido\r\n5. RPC busca en `app.payment_links` por `token_hash`\r\n6. RPC verifica que esté activo y no haya expirado\r\n7. RPC retorna información completa (salon, org, etc.)\r\n8. Edge Function retorna configuración al frontend\r\n9. Frontend muestra el formulario de checkout público\r\n\r\n---\r\n\r\n## Estado Actual del Sistema\r\n\r\n### ✅ Funcionando Correctamente\r\n\r\n1. **Generación de Payment Links**\r\n   - La función `create-payment-link` genera links correctamente\r\n   - Los tokens se generan de forma segura (32 bytes aleatorios)\r\n   - Los hashes se calculan correctamente (SHA-256)\r\n   - Los links se guardan en la base de datos con formato bytea\r\n\r\n2. **Validación de Payment Links**\r\n   - La función `get-payment-link-config` valida tokens correctamente\r\n   - No requiere autenticación para validación inicial\r\n   - Retorna información completa del link, salon y organización\r\n\r\n3. **Funciones RPC**\r\n   - `create_payment_link`: Funciona correctamente\r\n   - `get_payment_link_by_token`: Funciona correctamente\r\n   - Ambas manejan bytea correctamente\r\n\r\n4. **Integración Frontend-Backend**\r\n   - El modal de generación de links funciona\r\n   - Los links generados se muestran correctamente\r\n   - La página `/book/[token]` carga correctamente\r\n\r\n### ⚠️ Pendiente / Notas\r\n\r\n1. **Servicios No Configurados**\r\n   - El checkout público muestra \"No hay servicios disponibles\"\r\n   - Esto es esperado si no hay servicios configurados para el salón\r\n   - **Siguiente paso**: Verificar que hay servicios y precios configurados\r\n\r\n2. **Autenticación en Checkout Público**\r\n   - Actualmente el checkout público requiere autenticación con Google\r\n   - Esto puede ser un problema para algunos usuarios\r\n   - **Consideración**: Evaluar si se debe requerir autenticación o permitir checkout anónimo\r\n\r\n3. **Configuración de JWT en Edge Functions**\r\n   - La función `get-payment-link-config` está desplegada con `--no-verify-jwt`\r\n   - Esto es necesario para acceso público, pero debe revisarse la seguridad\r\n   - **Consideración**: Implementar validación adicional del token en la función\r\n\r\n---\r\n\r\n## Próximos Pasos Recomendados\r\n\r\n### 1. Configurar Servicios y Precios\r\n- Verificar que hay servicios creados en la organización\r\n- Verificar que hay precios configurados para los servicios en el salón\r\n- Probar el flujo completo de reserva con servicios reales\r\n\r\n### 2. Probar Flujo Completo de Reserva\r\n- Generar un payment link\r\n- Acceder al link como cliente\r\n- Seleccionar servicio\r\n- Seleccionar profesional\r\n- Seleccionar fecha y hora\r\n- Completar datos personales\r\n- Confirmar reserva\r\n- Verificar que el turno se crea en el sistema\r\n\r\n### 3. Integración con Mercado Pago (si aplica)\r\n- Verificar que la integración con Mercado Pago está configurada\r\n- Probar el flujo de pago con Mercado Pago\r\n- Verificar que los pagos se procesan correctamente\r\n- Verificar que los webhooks funcionan\r\n\r\n### 4. Mejoras de Seguridad\r\n- Implementar rate limiting en las Edge Functions públicas\r\n- Agregar validación adicional del token (además del hash)\r\n- Considerar agregar un nonce o timestamp al token\r\n- Implementar logging de accesos a payment links\r\n\r\n### 5. Mejoras de UX\r\n- Agregar mensaje cuando no hay servicios disponibles\r\n- Mejorar la UI del checkout público\r\n- Agregar validaciones en el frontend\r\n- Agregar feedback visual durante el proceso\r\n\r\n---\r\n\r\n## Comandos Útiles\r\n\r\n### Ver logs de Edge Functions\r\n```sql\r\n-- Usar MCP:\r\nmcp_supabase_get_logs(project_id: \"hawpywnmkatwlcbtffrg\", service: \"edge-function\")\r\n```\r\n\r\n### Probar función RPC directamente\r\n```sql\r\nSELECT public.create_payment_link(\r\n  'a63f505d-9410-420d-bb60-880cb318e191'::uuid,\r\n  (SELECT id FROM app.salons WHERE name = 'Demo Salon QA' LIMIT 1)::uuid,\r\n  'Test desde SQL',\r\n  NULL,\r\n  NULL,\r\n  NULL,\r\n  '{}'::jsonb\r\n);\r\n\r\nSELECT public.get_payment_link_by_token('6cc67b07395056cac923495bc92c5e8f42a049b9faaaabed4682d70ff60c9487');\r\n```\r\n\r\n### Desplegar Edge Functions\r\n```bash\r\n# Desplegar create-payment-link\r\nnpx --yes supabase functions deploy create-payment-link \\\r\n  --project-ref hawpywnmkatwlcbtffrg \\\r\n  --workdir \"C:\\Users\\Matecore\\Downloads\\Coreboard\"\r\n\r\n# Desplegar get-payment-link-config (sin JWT)\r\nnpx --yes supabase functions deploy get-payment-link-config \\\r\n  --project-ref hawpywnmkatwlcbtffrg \\\r\n  --workdir \"C:\\Users\\Matecore\\Downloads\\Coreboard\" \\\r\n  --no-verify-jwt\r\n```\r\n\r\n### Verificar estructura de tablas\r\n```sql\r\n-- Usar MCP:\r\nmcp_supabase_list_tables(project_id: \"hawpywnmkatwlcbtffrg\", schemas: [\"public\", \"app\"])\r\n```\r\n\r\n---\r\n\r\n## Lecciones Aprendidas\r\n\r\n1. **PostgREST y bytea**: PostgREST no puede manejar bytea directamente desde JavaScript. Es necesario usar funciones RPC en PostgreSQL para manejar bytea correctamente.\r\n\r\n2. **Extensiones de PostgreSQL**: Al usar funciones como `gen_random_bytes()` o `digest()`, es necesario verificar que la extensión `pgcrypto` esté habilitada y usar el schema correcto (`extensions.`).\r\n\r\n3. **JWT en Edge Functions**: Por defecto, Supabase Edge Functions requieren JWT. Para funciones públicas, es necesario desplegar con `--no-verify-jwt` o configurar la función como pública en el dashboard.\r\n\r\n4. **Nombres de tablas**: Es importante verificar los nombres reales de las tablas en la base de datos antes de crear funciones RPC que las referencien.\r\n\r\n5. **MCP de Supabase**: El MCP de Supabase es muy útil para aplicar migraciones y ejecutar queries sin necesidad de tener acceso directo a la base de datos.\r\n\r\n---\r\n\r\n## Referencias\r\n\r\n- [Supabase Edge Functions Documentation](https://supabase.com/docs/guides/functions)\r\n- [PostgreSQL pgcrypto Extension](https://www.postgresql.org/docs/current/pgcrypto.html)\r\n- [PostgREST Documentation](https://postgrest.org/)\r\n- [Supabase MCP Documentation](https://supabase.com/docs/guides/cli)\r\n\r\n---\r\n\r\n**Última actualización**: 2025-11-05\r\n**Estado**: ✅ Payment Links funcionando correctamente\r\n**Próximo paso**: Configurar servicios y probar flujo completo de reserva\r\n\r\nPróximos pasos:\r\nConfigurar servicios y precios\r\nProbar flujo completo de reserva\r\nIntegración con Mercado Pago\r\nMejoras de seguridad\r\nMejoras de UX",
  "sections": []
}