{
  "metadata": {
    "title": "Validadores - GuÃ­a de Uso",
    "path": "docs/VALIDATORS.md",
    "category": "technical",
    "tags": [
      "technical"
    ],
    "lastUpdated": "2025-11-15",
    "fileName": "VALIDATORS"
  },
  "content": "# Validadores - GuÃ­a de Uso\r\n\r\n## Iteraciones Completadas (1-6/6)\r\n\r\nEstos validadores implementan la lÃ³gica que faltaba en la arquitectura.\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 1: Context Validator\r\n\r\n**Archivo:** `src/lib/contextValidator.ts`\r\n\r\n**Responsabilidad:** Garantizar que frontend y backend hablen del mismo contexto.\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { validateContext, getServerContext } from '@/lib/contextValidator';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\n// En un hook o componente:\r\nconst { user } = useAuth();\r\nconst serverContext = getServerContext(user);\r\n\r\nconst frontendContext = {\r\n  org_id: 'org-123',      // Lo que el cliente envÃ­a\r\n  salon_id: 'salon-456',  // Lo que el cliente envÃ­a\r\n};\r\n\r\nconst result = validateContext(frontendContext, serverContext, user);\r\n\r\nif (result.valid) {\r\n  // OK - usar result.context para la operaciÃ³n\r\n  console.log(result.context); // { user_id_real, org_id_server, org_id_front, ... }\r\n} else {\r\n  // PROBLEMA\r\n  console.error(result.error?.code); // 'ORG_DIVERGENCE' | 'MISSING_USER' | 'MISSING_ORG'\r\n  console.error(result.error?.message);\r\n  console.error(result.error?.recovery); // 'resync_orgs' | 'refresh_token'\r\n}\r\n```\r\n\r\n### Posibles Resultados\r\n\r\n```\r\nâœ… valid: true\r\n   state: 'clean'\r\n   â†’ Contexto sincronizado\r\n\r\nâŒ valid: false\r\n   state: 'divergent'\r\n   error.code: 'ORG_DIVERGENCE'\r\n   â†’ Frontend y backend no coinciden en org_id\r\n\r\nâŒ valid: false\r\n   state: 'missing_data'\r\n   error.code: 'MISSING_USER' | 'MISSING_ORG'\r\n   â†’ Faltan datos crÃ­ticos\r\n```\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 2: Appointment Validator\r\n\r\n**Archivo:** `src/lib/appointmentValidator.ts`\r\n\r\n**Responsabilidad:** Validar que un turno cumpla TODAS las reglas de negocio.\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { AppointmentValidator, AppointmentIntent } from '@/lib/appointmentValidator';\r\n\r\nconst validator = new AppointmentValidator(\r\n  salons,      // MockSalon[]\r\n  services,    // MockService[]\r\n  employees,   // MockEmployee[]\r\n  appointments // MockAppointment[] (turnos existentes)\r\n);\r\n\r\nconst appointmentIntent: AppointmentIntent = {\r\n  org_id: 'org-123',\r\n  salon_id: 'salon-456',\r\n  client_id: 'client-789',\r\n  employee_id: 'emp-001',\r\n  service_id: 'svc-001',\r\n  starts_at: '2025-10-30T14:30:00', // ISO 8601\r\n};\r\n\r\nconst result = validator.validate(appointmentIntent);\r\n\r\nif (result.valid) {\r\n  // âœ… Puede ir a la BD\r\n  console.log(result.normalized_appointment);\r\n} else {\r\n  // âŒ RompiÃ³ una regla\r\n  console.error(result.error_code); // Ver tabla abajo\r\n  console.error(result.message);\r\n  console.log(result.suggestions); // Sugerencias al usuario\r\n}\r\n```\r\n\r\n### Validaciones en Orden\r\n\r\n```\r\n1. Campos requeridos (org, salon, employee, service, starts_at)\r\n2. Formato de fecha (ISO 8601)\r\n3. âœ“ SalÃ³n pertenece a la org\r\n4. âœ“ Servicio pertenece al salÃ³n\r\n5. âœ“ Empleado trabaja en el salÃ³n\r\n6. âœ“ Empleado puede hacer el servicio\r\n7. âœ“ SalÃ³n abre ese dÃ­a/hora\r\n8. âœ“ No hay conflicto horario\r\n```\r\n\r\n### Posibles Errores\r\n\r\n```typescript\r\nerror_code: 'SALON_NOT_IN_ORG'\r\n  â†’ SalÃ³n no existe en esa org\r\n\r\nerror_code: 'SERVICE_NOT_IN_SALON'\r\n  â†’ Servicio no existe en ese salÃ³n\r\n\r\nerror_code: 'EMPLOYEE_NOT_IN_SALON'\r\n  â†’ Empleado no trabaja en ese salÃ³n\r\n\r\nerror_code: 'EMPLOYEE_CANT_DO_SERVICE'\r\n  â†’ Empleado no estÃ¡ capacitado\r\n  suggestions: [\"Asigna otro empleado\", \"Agrega capacidad al empleado\"]\r\n\r\nerror_code: 'SALON_CLOSED'\r\n  â†’ SalÃ³n no abre ese dÃ­a/hora\r\n  suggestions: [\"Elige otro horario\", \"Elige otro dÃ­a\"]\r\n\r\nerror_code: 'EMPLOYEE_CONFLICT'\r\n  â†’ Empleado ya tiene otro turno\r\n  suggestions: [\"Mueve a otro horario\", \"Asigna otro empleado\"]\r\n```\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 3: Context State Manager\r\n\r\n**Archivo:** `src/lib/contextStateManager.ts`\r\n\r\n**Responsabilidad:** Detectar cambios de salÃ³n y bloquear operaciones durante transiciones.\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { getContextStateManager } from '@/lib/contextStateManager';\r\n\r\nconst stateManager = getContextStateManager();\r\n\r\n// Cuando el usuario cambia de salÃ³n:\r\nstateManager.notifySalonChange('salon-new-id');\r\n// Estado cambia a 'updating'\r\n// Se limpian todos los recursos sincronizados\r\n\r\n// Cuando cada recurso termine de cargar:\r\nstateManager.notifyResourceSynced('appointments');  // âœ“\r\nstateManager.notifyResourceSynced('clients');       // âœ“\r\nstateManager.notifyResourceSynced('employees');     // âœ“\r\nstateManager.notifyResourceSynced('salon_services');// âœ“\r\n// Cuando todos â†’ Estado cambia a 'idle'\r\n\r\n// Antes de crear un turno:\r\nconst check = stateManager.canOperate();\r\n\r\nif (check.can_operate) {\r\n  // âœ… Puede crear\r\n} else {\r\n  // âŒ Esperando sincronizaciÃ³n\r\n  console.log(check.reason);\r\n  console.log(check.resources_pending); // ['appointments', 'clients', ...]\r\n}\r\n```\r\n\r\n### Estados\r\n\r\n```\r\n'idle'      â†’ Todo sincronizado, puede operar\r\n'updating'  â†’ Se estÃ¡ cambiando de salÃ³n, esperar\r\n'error'     â†’ Error crÃ­tico, recargar pÃ¡gina\r\n```\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 3.5: Operation Validator (Orquestador)\r\n\r\n**Archivo:** `src/lib/operationValidator.ts`\r\n\r\n**Responsabilidad:** Integrar contexto + estado + validaciÃ³n de negocio.\r\n\r\n### Uso Principal\r\n\r\n```typescript\r\nimport { validateCreateAppointment } from '@/lib/operationValidator';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\n\r\nconst { user } = useAuth();\r\n\r\nconst result = validateCreateAppointment(appointmentIntent, user);\r\n\r\nswitch (result.status) {\r\n  case 'valido':\r\n    // âœ… Puede ir a la BD\r\n    const payload = result.payload; // Normalizado\r\n    await createAppointmentInDB(payload);\r\n    break;\r\n\r\n  case 'invalido':\r\n    // âŒ Regla de negocio rota\r\n    toast.error(result.message);\r\n    console.log(result.suggestions);\r\n    break;\r\n\r\n  case 'inconsistente':\r\n    // âš ï¸ Org del front â‰  org del server\r\n    toast.warning('Tu contexto estÃ¡ desincronizado');\r\n    console.log(result.recovery_action); // 'resync_orgs' | 'refresh_token'\r\n    break;\r\n\r\n  case 'inconsistente-temporal':\r\n    // â³ EstÃ¡ cambiando de salÃ³n\r\n    toast.info('Espera a que se carguen todos los datos');\r\n    console.log(result.resources_pending);\r\n    break;\r\n}\r\n```\r\n\r\n### Estados Posibles\r\n\r\n```typescript\r\nstatus: 'valido'\r\n  â†’ Puede ejecutarse\r\n  â†’ result.payload contiene la operaciÃ³n normalizada\r\n  â†’ result.context tiene el contexto sincronizado\r\n\r\nstatus: 'invalido'\r\n  â†’ RompiÃ³ regla de negocio\r\n  â†’ result.error_code y result.message describen quÃ© pasÃ³\r\n  â†’ result.suggestions tiene recomendaciones\r\n\r\nstatus: 'inconsistente'\r\n  â†’ Org del front â‰  org del server\r\n  â†’ result.recovery_action dice quÃ© hacer\r\n\r\nstatus: 'inconsistente-temporal'\r\n  â†’ Se estÃ¡ cambiando de salÃ³n\r\n  â†’ result.resources_pending lista quÃ© falta sincronizar\r\n```\r\n\r\n---\r\n\r\n## ðŸ”— IntegraciÃ³n TÃ­pica en Hook\r\n\r\n```typescript\r\nimport { useCallback } from 'react';\r\nimport { useAuth } from '@/contexts/AuthContext';\r\nimport { validateCreateAppointment } from '@/lib/operationValidator';\r\nimport { getContextStateManager } from '@/lib/contextStateManager';\r\nimport { toast } from 'sonner';\r\n\r\nexport function useAppointmentsValidator() {\r\n  const { user } = useAuth();\r\n\r\n  return useCallback(async (appointmentIntent) => {\r\n    // 1. Validar todo\r\n    const validation = validateCreateAppointment(appointmentIntent, user);\r\n\r\n    // 2. Decidir quÃ© hacer\r\n    if (validation.status !== 'valido') {\r\n      toast.error(validation.message);\r\n      return null;\r\n    }\r\n\r\n    // 3. Si OK, ir a la BD\r\n    try {\r\n      const result = await supabase\r\n        .from('appointments')\r\n        .insert(validation.payload);\r\n\r\n      if (result.error) throw result.error;\r\n\r\n      // Notificar que se sincronizÃ³\r\n      const stateManager = getContextStateManager();\r\n      stateManager.notifyResourceSynced('appointments');\r\n\r\n      return result.data;\r\n    } catch (error) {\r\n      toast.error('Error al crear turno');\r\n      stateManager.notifyError();\r\n      return null;\r\n    }\r\n  }, [user]);\r\n}\r\n```\r\n\r\n---\r\n\r\n## ðŸ“‹ Checklist: SeÃ±ales de que EstÃ¡s Haciendo Bien\r\n\r\nâœ… Antes de crear turno, llamas a `validateCreateAppointment()`\r\nâœ… Manejas los 4 posibles estados de resultado\r\nâœ… Notificas cambios de salÃ³n con `notifySalonChange()`\r\nâœ… Notificas recursos sincronizados con `notifyResourceSynced()`\r\nâœ… Bloqueas operaciones durante `inconsistente-temporal`\r\nâœ… Los errores tienen `suggestions` para el usuario\r\nâœ… Muestras `recovery_action` cuando hay divergencia\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 6: Employee Validator\r\n\r\n**Archivo:** `src/lib/employeeValidator.ts`\r\n\r\n**Responsabilidad:** Validar reglas de negocio de empleados (regla de oro: Empleado = Usuario autenticado).\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { \r\n  filterValidEmployees,\r\n  validateEmployeeStatus,\r\n  validateEmployeeInSalon,\r\n  validateEmployeeForAppointment \r\n} from '@/lib/employeeValidator';\r\n\r\n// Filtrar empleados sin user_id\r\nconst validEmployees = filterValidEmployees(employees);\r\n// Solo retorna empleados con user_id vÃ¡lido\r\n\r\n// Validar estado de empleado\r\nconst statusCheck = validateEmployeeStatus(employee);\r\nif (!statusCheck.valid) {\r\n  console.error(statusCheck.error_code); // 'EMPLOYEE_INACTIVE' | 'EMPLOYEE_DELETED'\r\n}\r\n\r\n// Validar asignaciÃ³n a salÃ³n\r\nconst assignmentCheck = validateEmployeeInSalon(\r\n  employeeId,\r\n  salonId,\r\n  salonAssignments // Array de { employee_id, salon_id, active }\r\n);\r\nif (!assignmentCheck.valid) {\r\n  console.error(assignmentCheck.error_code); // 'EMPLOYEE_NOT_IN_SALON'\r\n}\r\n\r\n// ValidaciÃ³n completa para turno\r\nconst appointmentCheck = validateEmployeeForAppointment({\r\n  employeeId,\r\n  salonId,\r\n  employee,\r\n  salonAssignments\r\n});\r\nif (!appointmentCheck.valid) {\r\n  console.error(appointmentCheck.error_code);\r\n  // 'EMPLOYEE_MISSING_USER' | 'EMPLOYEE_INACTIVE' | 'EMPLOYEE_NOT_IN_SALON'\r\n}\r\n```\r\n\r\n### Regla de Oro\r\n\r\n```\r\nEmpleado = Usuario autenticado dentro de una organizaciÃ³n.\r\n\r\nNo existe \"empleado sin usuario\". Si no tiene user_id, no es empleado.\r\n```\r\n\r\n### Validaciones\r\n\r\n1. **`filterValidEmployees`**: Filtra empleados sin `user_id`\r\n2. **`validateEmployeeStatus`**: Verifica que empleado estÃ© activo y no eliminado\r\n3. **`validateEmployeeInSalon`**: Verifica asignaciÃ³n activa a salÃ³n\r\n4. **`validateEmployeeForAppointment`**: ValidaciÃ³n completa para crear turno\r\n\r\n### Posibles Errores\r\n\r\n```typescript\r\nerror_code: 'EMPLOYEE_MISSING_USER'\r\n  â†’ Empleado no tiene user_id (regla de oro violada)\r\n\r\nerror_code: 'EMPLOYEE_INACTIVE'\r\n  â†’ Empleado estÃ¡ inactivo (active = false)\r\n\r\nerror_code: 'EMPLOYEE_DELETED'\r\n  â†’ Empleado fue eliminado (deleted_at no es null)\r\n\r\nerror_code: 'EMPLOYEE_NOT_IN_SALON'\r\n  â†’ Empleado no estÃ¡ asignado al salÃ³n\r\n  â†’ o asignaciÃ³n existe pero active = false\r\n```\r\n\r\n### IntegraciÃ³n\r\n\r\n```typescript\r\n// En useEmployees:\r\nimport { filterValidEmployees } from '@/lib/employeeValidator';\r\n\r\nconst fetchEmployees = async () => {\r\n  const { data } = await supabase.from('employees').select();\r\n  const validEmployees = filterValidEmployees(data || []);\r\n  setEmployees(validEmployees);\r\n};\r\n\r\n// En turnosStore:\r\nimport { validateEmployeeInSalon } from '@/lib/employeeValidator';\r\n\r\nfunction validateTurno(turno: Turno) {\r\n  // ... otras validaciones ...\r\n  const empCheck = validateEmployeeInSalon(\r\n    turno.stylist,\r\n    turno.salonId,\r\n    salonAssignments\r\n  );\r\n  if (!empCheck.valid) {\r\n    return { valid: false, message: empCheck.message };\r\n  }\r\n}\r\n\r\n// En OrganizationView:\r\nimport { validateEmployeeHasUser } from '@/lib/employeeValidator';\r\n\r\nconst handleSaveEmployee = async () => {\r\n  if (!userId) {\r\n    toast.error('Empleado debe tener user_id');\r\n    return;\r\n  }\r\n  const validation = validateEmployeeHasUser(employeeData);\r\n  if (!validation.valid) {\r\n    toast.error(validation.message);\r\n    return;\r\n  }\r\n  // ... crear empleado ...\r\n};\r\n```\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 4: Permission Resolver\r\n\r\n**Archivo:** `src/lib/permissionResolver.ts`\r\n\r\n**Responsabilidad:** Tabla de decisiones (rol, operaciÃ³n) â†’ permitido/rechazado\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { checkPermission } from '@/lib/permissionResolver';\r\n\r\nconst result = checkPermission({\r\n  user_id: 'user-123',\r\n  role: 'employee',  // del server, no del front\r\n  operation: 'appointment.create.own_salon',\r\n  scoped_org_id: 'org-456',    // lo que el server dice\r\n  scoped_salon_id: 'salon-789', // lo que el server dice\r\n  resource_salon_id: 'salon-789',  // lo que la operaciÃ³n quiere\r\n});\r\n\r\nif (result.permitted) {\r\n  // âœ… Puede ejecutar\r\n} else {\r\n  // âŒ Rechazado\r\n  console.log(result.reason); // 'ROL_NO_AUTORIZA_OPERACION' | 'SALON_SCOPE_VIOLATION'\r\n}\r\n```\r\n\r\n### Matriz de Permisos\r\n\r\n```\r\nviewer:\r\n  âœ… appointment.read.all\r\n  âœ… client.read.all\r\n  âœ… salon.read\r\n  âœ… org.read\r\n  âŒ Nada de creaciÃ³n/ediciÃ³n\r\n\r\nemployee:\r\n  âœ… appointment: read/create/update/delete (solo own_salon)\r\n  âœ… client: read/create/update\r\n  âœ… finance.read: own_salon\r\n  âŒ Nada de org.manage\r\n\r\nadmin:\r\n  âœ… appointment: todos\r\n  âœ… client: todos\r\n  âœ… employee: todos\r\n  âœ… salon: todos\r\n  âœ… finance: todos\r\n  âœ… org.manage\r\n  âœ… org.invite_user\r\n  âŒ Nada mÃ¡s\r\n\r\nowner:\r\n  âœ… TODO\r\n```\r\n\r\n### Operaciones Scopeadas\r\n\r\nLas que terminan en `own_salon` requieren validaciÃ³n adicional:\r\n\r\n```\r\n'appointment.create.own_salon'\r\n  â†’ Puedes crear turnos, pero SOLO en tu salÃ³n\r\n  â†’ Si intento crear en otro salÃ³n â†’ SALON_SCOPE_VIOLATION\r\n\r\n'finance.read.own_salon'\r\n  â†’ Puedes leer finanzas de tu salÃ³n\r\n  â†’ Si intento leer otro salÃ³n â†’ rechazado\r\n```\r\n\r\n---\r\n\r\n## âœ… IteraciÃ³n 5: Demo Adapter\r\n\r\n**Archivo:** `src/lib/demoAdapter.ts`\r\n\r\n**Responsabilidad:** Demo que no miente - aplica mismas validaciones que real\r\n\r\n### Concepto\r\n\r\n```\r\nDemo normal:\r\n  input â†’ demoStore.create() â†’ OK siempre\r\n\r\nDemo inteligente:\r\n  input\r\n    â†“\r\n  contextValidator (Â¿misma org?)\r\n    â†“\r\n  contextStateManager (Â¿transitando?)\r\n    â†“\r\n  permissionResolver (Â¿puede este rol?)\r\n    â†“\r\n  appointmentValidator (Â¿turno vÃ¡lido?)\r\n    â†“\r\n  demoStore.create() â† SOLO si todo pasÃ³\r\n```\r\n\r\n### Uso BÃ¡sico\r\n\r\n```typescript\r\nimport { executeOperationWithDemoFallback } from '@/lib/demoAdapter';\r\nimport { isDemoMode } from '@/lib/demoAdapter';\r\n\r\nconst result = await executeOperationWithDemoFallback({\r\n  operation: 'create_appointment',\r\n  payload: appointmentIntent,\r\n  user,\r\n  onRealExecute: async (validatedPayload) => {\r\n    // Esto solo se ejecuta en modo real\r\n    const { data, error } = await supabase\r\n      .from('appointments')\r\n      .insert(validatedPayload);\r\n    return { data, error };\r\n  }\r\n});\r\n\r\nif (result.status === 'valido') {\r\n  // âœ… Creado exitosamente\r\n  if (result.demo_warning === 'DEMO_SECURITY_LIGHTER') {\r\n    // âš ï¸ En demo: las validaciones son iguales, pero RLS no estÃ¡\r\n  }\r\n} else {\r\n  // âŒ FallÃ³ por alguna razÃ³n\r\n  console.log(result.message);\r\n}\r\n```\r\n\r\n### Diferencias Demo vs Real\r\n\r\n```\r\nDemo:\r\n  âœ… Mismas validaciones de contexto\r\n  âœ… Mismas validaciones de permisos\r\n  âœ… Mismas validaciones de negocio\r\n  âŒ Sin RLS (Row Level Security)\r\n  âŒ Sin persistencia en BD real\r\n  âš ï¸ Advertencia: DEMO_SECURITY_LIGHTER\r\n\r\nReal:\r\n  âœ… Mismas validaciones de contexto\r\n  âœ… Mismas validaciones de permisos\r\n  âœ… Mismas validaciones de negocio\r\n  âœ… Con RLS\r\n  âœ… Persistencia en Supabase\r\n```\r\n\r\n---\r\n\r\n## ðŸ”„ Pipeline Completo\r\n\r\nCuando el sistema recibe una operaciÃ³n, hace esto:\r\n\r\n```typescript\r\n// 1. Detectar si es demo o real\r\nconst isDemo = process.env.NEXT_PUBLIC_DEMO_MODE === 'true';\r\n\r\n// 2. Ejecutar el adaptador apropiado\r\nif (isDemo) {\r\n  result = await adaptDemoOperation({\r\n    operation: 'create_appointment',\r\n    payload: appointmentIntent,\r\n    context: { user, isDemo: true }\r\n  });\r\n} else {\r\n  result = await executeOperationWithDemoFallback({\r\n    operation: 'create_appointment',\r\n    payload: appointmentIntent,\r\n    user,\r\n    onRealExecute: /* funciÃ³n que va a Supabase */\r\n  });\r\n}\r\n\r\n// 3. El resultado SIEMPRE es uno de estos:\r\nswitch (result.status) {\r\n  case 'valido':\r\n    // âœ… Puede ejecutarse\r\n    // result.payload contiene los datos normalizados\r\n    break;\r\n  \r\n  case 'invalido':\r\n    // âŒ RompiÃ³ regla de negocio\r\n    // result.error_code y result.message describen quÃ© pasÃ³\r\n    break;\r\n  \r\n  case 'inconsistente':\r\n    // âš ï¸ Org del front â‰  org del server\r\n    // result.recovery_action dice quÃ© hacer\r\n    break;\r\n  \r\n  case 'inconsistente-temporal':\r\n    // â³ EstÃ¡ cambiando de salÃ³n\r\n    // result.resources_pending lista quÃ© falta sincronizar\r\n    break;\r\n  \r\n  case 'rechazado-por-permisos':\r\n    // ðŸ”’ Rol no autoriza\r\n    // result.permission_check contiene detalles\r\n    break;\r\n}\r\n```\r\n\r\n---\r\n\r\n## ðŸ§ª Checklist Final (1-6 Completadas)\r\n\r\nâœ… Permisos se validan ANTES de reglas de negocio\r\nâœ… Operaciones scopeadas (own_salon) se validan en contexto\r\nâœ… Demo aplica mismas validaciones que real\r\nâœ… Demo agrega advertencia DEMO_SECURITY_LIGHTER\r\nâœ… Pipeline es idÃ©ntico: demo vs real (solo cambia persistencia)\r\nâœ… 5 estados de resultado posibles (no hay \"invenciones\")\r\nâœ… Todos los inputs vienen del server (nada del front sin validar)\r\nâœ… Sugerencias Ãºtiles en cada error\r\nâœ… Recovery actions claros (resync, reload, wait, refresh_token)\r\nâœ… **Empleados validados con user_id obligatorio (regla de oro)**\r\nâœ… **Asignaciones salÃ³n-empleado validadas antes de crear turno**\r\nâœ… **turnosStore integra validaciones de empleados**\r\n\r\n---\r\n\r\n## ðŸ“Š Resumen de Iteraciones 1-6\r\n\r\n| Iter | Archivo | Responsabilidad |\r\n|------|---------|---|\r\n| 1 | contextValidator | SincronizaciÃ³n org/usuario front vs back |\r\n| 2 | appointmentValidator | ValidaciÃ³n de reglas de negocio de turnos |\r\n| 3 | contextStateManager | Bloqueo durante transiciones |\r\n| 3.5 | operationValidator | Orquestador que integra 1+2+3 |\r\n| 4 | permissionResolver | RBAC - matriz rol Ã— operaciÃ³n |\r\n| 5 | demoAdapter | Demo que valida igual a real |\r\n| 6 | employeeValidator | ValidaciÃ³n de empleados (regla de oro: user_id obligatorio) |\r\n\r\n---\r\n\r\n## ðŸš€ QuÃ© Sigue\r\n\r\nCon estas 6 iteraciones, el sistema estÃ¡ listo para:\r\n- âœ… AuditorÃ­a (\"quiÃ©n rechazÃ³ y por quÃ©\")\r\n- âœ… Sugerencias de horario (IA-friendly)\r\n- âœ… Enforcement en serverless (edge functions)\r\n- âœ… Logging de operaciones rechazadas\r\n- âœ… Rate limiting por rol\r\n- âœ… Notificaciones en tiempo real\r\n- âœ… **Motor de Compensaciones** (siguiente fase: cÃ¡lculo de comisiones, sueldos, propinas)\r\n\r\n## ðŸ”„ IntegraciÃ³n con Sistema Global de Turnos\r\n\r\nLos validadores se integran con `turnosStore`:\r\n\r\n```typescript\r\n// turnosStore usa employeeValidator\r\nimport { validateEmployeeInSalon } from '@/lib/employeeValidator';\r\n\r\nfunction validateTurno(turno: Turno) {\r\n  // ... validaciones de datos ...\r\n  \r\n  // Validar empleado asignado al salÃ³n\r\n  const empCheck = validateEmployeeInSalon(\r\n    turno.stylist,\r\n    turno.salonId,\r\n    salonAssignments\r\n  );\r\n  if (!empCheck.valid) {\r\n    return { valid: false, message: empCheck.message };\r\n  }\r\n  \r\n  // ... mÃ¡s validaciones ...\r\n}\r\n\r\n// useTurnos expone validaciones\r\nexport function useTurnos() {\r\n  return {\r\n    // ... otros mÃ©todos ...\r\n    validateTurno: (turno) => turnosStore.validateTurno(turno),\r\n    checkConflicts: (turno) => turnosStore.checkConflicts(turno),\r\n  };\r\n}\r\n```\r\n\r\nMP_TEST_PUBLIC_KEY=TEST-0ca3aa64-6280-4f79-b276-b96ab1e3f561\r\nMP_TEST_ACCESS_TOKEN=TEST-311317450627289-110412-41b453f8a762858b9a65fcf3e7dd641f-575122857\r\nMP_CLIENT_ID=311317450627289\r\nMP_CLIENT_SECRET=ACAOfFSl4KkULdcRE6WlUUHMNwmqrVvq\r\nMP_TOKEN_KEY=f9d2b8a0e1c4b39f772c5a6d84f09e3b51a27cb08e6d9354a7dcb61f92ad4b03\r\nPUBLIC_EDGE_BASE_URL=https://hawpywnmkatwlcbtffrg.supabase.co\r\nNEXT_PUBLIC_APP_URL=https://coreboard.vercel.app\r\n\r\n\r\n",
  "sections": []
}